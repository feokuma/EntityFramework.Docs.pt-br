---
title: Considerações sobre desempenho para o EF4, EF5 e EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: f8fa1001c85366e169cf50e89efdb65bd92b671e
ms.sourcegitcommit: f277883a5ed28eba57d14aaaf17405bc1ae9cf94
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 05/18/2019
ms.locfileid: "65874604"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a><span data-ttu-id="d7b80-102">Considerações de desempenho do EF 4, 5 e 6</span><span class="sxs-lookup"><span data-stu-id="d7b80-102">Performance considerations for EF 4, 5, and 6</span></span>
<span data-ttu-id="d7b80-103">Por David Obando, Eric Dettinger e outros</span><span class="sxs-lookup"><span data-stu-id="d7b80-103">By David Obando, Eric Dettinger and others</span></span>

<span data-ttu-id="d7b80-104">Publicado em: Abril de 2012</span><span class="sxs-lookup"><span data-stu-id="d7b80-104">Published: April 2012</span></span>

<span data-ttu-id="d7b80-105">Última atualização: Maio de 2014</span><span class="sxs-lookup"><span data-stu-id="d7b80-105">Last updated: May 2014</span></span>

------------------------------------------------------------------------

## <a name="1-introduction"></a><span data-ttu-id="d7b80-106">1. Introdução</span><span class="sxs-lookup"><span data-stu-id="d7b80-106">1. Introduction</span></span>

<span data-ttu-id="d7b80-107">Estruturas de mapeamento relacional de objeto são uma maneira conveniente para fornecer uma abstração para acesso a dados em um aplicativo orientado a objeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-107">Object-Relational Mapping frameworks are a convenient way to provide an abstraction for data access in an object-oriented application.</span></span> <span data-ttu-id="d7b80-108">Para aplicativos .NET, recomendada pela Microsoft que é o O/RM Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="d7b80-108">For .NET applications, Microsoft's recommended O/RM is Entity Framework.</span></span> <span data-ttu-id="d7b80-109">Com qualquer abstração, desempenho pode se tornar uma preocupação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-109">With any abstraction though, performance can become a concern.</span></span>

<span data-ttu-id="d7b80-110">Este white paper foi escrito para mostrar as considerações de desempenho ao desenvolver aplicativos usando o Entity Framework, para dar aos desenvolvedores uma ideia do que os algoritmos internos do Entity Framework que podem afetar o desempenho e para fornecer dicas para investigação e melhorando o desempenho de seus aplicativos que usam o Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="d7b80-110">This whitepaper was written to show the performance considerations when developing applications using Entity Framework, to give developers an idea of the Entity Framework internal algorithms that can affect performance, and to provide tips for investigation and improving performance in their applications that use Entity Framework.</span></span> <span data-ttu-id="d7b80-111">Há uma série de tópicos de bom desempenho já disponíveis na web e, tentamos apontando para esses recursos sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="d7b80-111">There are a number of good topics on performance already available on the web, and we've also tried pointing to these resources where possible.</span></span>

<span data-ttu-id="d7b80-112">O desempenho é um assunto complicado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-112">Performance is a tricky topic.</span></span> <span data-ttu-id="d7b80-113">Este white paper destina-se como um recurso para ajudar a tornar o desempenho relacionados a decisões para seus aplicativos que usam o Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="d7b80-113">This whitepaper is intended as a resource to help you make performance related decisions for your applications that use Entity Framework.</span></span> <span data-ttu-id="d7b80-114">Incluímos algumas métricas de teste para demonstrar o desempenho, mas essas métricas não se destinam como absolutos indicadores de desempenho, que você verá em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-114">We have included some test metrics to demonstrate performance, but these metrics aren't intended as absolute indicators of the performance you will see in your application.</span></span>

<span data-ttu-id="d7b80-115">Para fins práticos, este documento considera o Entity Framework 4 é executado no .NET 4.0 e o Entity Framework 5 e 6 são executados no .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="d7b80-115">For practical purposes, this document assumes Entity Framework 4 is run under .NET 4.0 and Entity Framework 5 and 6 are run under .NET 4.5.</span></span> <span data-ttu-id="d7b80-116">Muitas das melhorias de desempenho feitas para o Entity Framework 5 residem dentro de componentes principais que acompanham o .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="d7b80-116">Many of the performance improvements made for Entity Framework 5 reside within the core components that ship with .NET 4.5.</span></span>

<span data-ttu-id="d7b80-117">Entity Framework 6 é um fora da versão de banda e não depende dos componentes do Entity Framework que acompanham o .NET.</span><span class="sxs-lookup"><span data-stu-id="d7b80-117">Entity Framework 6 is an out of band release and does not depend on the Entity Framework components that ship with .NET.</span></span> <span data-ttu-id="d7b80-118">Entity Framework 6 trabalhar no .NET 4.0 e .NET 4.5 e pode oferecer um benefício de desempenho grande para aqueles que ainda não tiver atualizado do .NET 4.0, mas deseja que os bits mais recentes do Entity Framework em seus aplicativos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-118">Entity Framework 6 work on both .NET 4.0 and .NET 4.5, and can offer a big performance benefit to those who haven’t upgraded from .NET 4.0 but want the latest Entity Framework bits in their application.</span></span> <span data-ttu-id="d7b80-119">Quando este documento menciona o Entity Framework 6, ele se refere a versão mais recente disponível no momento da redação deste artigo: versão 6.1.0.</span><span class="sxs-lookup"><span data-stu-id="d7b80-119">When this document mentions Entity Framework 6, it refers to the latest version available at the time of this writing: version 6.1.0.</span></span>

## <a name="2-cold-vs-warm-query-execution"></a><span data-ttu-id="d7b80-120">2. Frios vs. Execução de consulta quente</span><span class="sxs-lookup"><span data-stu-id="d7b80-120">2. Cold vs. Warm Query Execution</span></span>

<span data-ttu-id="d7b80-121">Na primeira vez que qualquer consulta é feita em relação a um determinado modelo, o Entity Framework faz muito trabalho nos bastidores para carregar e validar o modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-121">The very first time any query is made against a given model, the Entity Framework does a lot of work behind the scenes to load and validate the model.</span></span> <span data-ttu-id="d7b80-122">Com frequência chamamos essa primeira consulta como uma consulta "fria".</span><span class="sxs-lookup"><span data-stu-id="d7b80-122">We frequently refer to this first query as a "cold" query.</span></span><span data-ttu-id="d7b80-123">  Mais consultas em um modelo carregado já são conhecidas como "passivos" consultas e são muito mais rápidas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-123">  Further queries against an already loaded model are known as "warm" queries, and are much faster.</span></span>

<span data-ttu-id="d7b80-124">Vamos dar uma visão geral de onde o tempo é gasto ao executar uma consulta usando o Entity Framework e ver onde as coisas estão melhorando no Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="d7b80-124">Let’s take a high-level view of where time is spent when executing a query using Entity Framework, and see where things are improving in Entity Framework 6.</span></span>

<span data-ttu-id="d7b80-125">**Primeira execução da consulta – consulta fria**</span><span class="sxs-lookup"><span data-stu-id="d7b80-125">**First Query Execution – cold query**</span></span>

| <span data-ttu-id="d7b80-126">Gravações de usuário do código</span><span class="sxs-lookup"><span data-stu-id="d7b80-126">Code User Writes</span></span>                                                                                     | <span data-ttu-id="d7b80-127">Ação</span><span class="sxs-lookup"><span data-stu-id="d7b80-127">Action</span></span>                    | <span data-ttu-id="d7b80-128">EF4 Impacto de desempenho</span><span class="sxs-lookup"><span data-stu-id="d7b80-128">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="d7b80-129">EF5 Impacto de desempenho</span><span class="sxs-lookup"><span data-stu-id="d7b80-129">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="d7b80-130">EF6 Impacto de desempenho</span><span class="sxs-lookup"><span data-stu-id="d7b80-130">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="d7b80-131">Criação de contexto</span><span class="sxs-lookup"><span data-stu-id="d7b80-131">Context creation</span></span>          | <span data-ttu-id="d7b80-132">Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-132">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="d7b80-133">Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-133">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="d7b80-134">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-134">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="d7b80-135">Criação de expressão de consulta</span><span class="sxs-lookup"><span data-stu-id="d7b80-135">Query expression creation</span></span> | <span data-ttu-id="d7b80-136">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-136">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="d7b80-137">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-137">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="d7b80-138">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-138">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="d7b80-139">Execução de consulta LINQ</span><span class="sxs-lookup"><span data-stu-id="d7b80-139">LINQ query execution</span></span>      | <span data-ttu-id="d7b80-140">-Metadados carregamento: Alta, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-140">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="d7b80-141">-Exibir geração: Potencialmente muito alta, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-141">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="d7b80-142">-Avaliação a parâmetro: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-142">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="d7b80-143">-Tradução da consulta: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-143">- Query translation: Medium</span></span> <br/> <span data-ttu-id="d7b80-144">-Geração de materializer: Médio, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-144">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="d7b80-145">-Execução de consulta banco de dados: Potencialmente alto</span><span class="sxs-lookup"><span data-stu-id="d7b80-145">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="d7b80-146">+ Connection</span><span class="sxs-lookup"><span data-stu-id="d7b80-146">+ Connection.Open</span></span> <br/> <span data-ttu-id="d7b80-147">+ ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="d7b80-147">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="d7b80-148">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="d7b80-148">+ DataReader.Read</span></span> <br/> <span data-ttu-id="d7b80-149">Materialização de objeto: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-149">Object materialization: Medium</span></span> <br/> <span data-ttu-id="d7b80-150">-Pesquisa identity: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-150">- Identity lookup: Medium</span></span> | <span data-ttu-id="d7b80-151">-Metadados carregamento: Alta, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-151">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="d7b80-152">-Exibir geração: Potencialmente muito alta, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-152">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="d7b80-153">-Avaliação a parâmetro: Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-153">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="d7b80-154">-Tradução da consulta: Médio, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-154">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="d7b80-155">-Geração de materializer: Médio, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-155">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="d7b80-156">-Execução de consulta banco de dados: Potencialmente alto (melhor consultas em algumas situações)</span><span class="sxs-lookup"><span data-stu-id="d7b80-156">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="d7b80-157">+ Connection</span><span class="sxs-lookup"><span data-stu-id="d7b80-157">+ Connection.Open</span></span> <br/> <span data-ttu-id="d7b80-158">+ ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="d7b80-158">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="d7b80-159">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="d7b80-159">+ DataReader.Read</span></span> <br/> <span data-ttu-id="d7b80-160">Materialização de objeto: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-160">Object materialization: Medium</span></span> <br/> <span data-ttu-id="d7b80-161">-Pesquisa identity: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-161">- Identity lookup: Medium</span></span> | <span data-ttu-id="d7b80-162">-Metadados carregamento: Alta, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-162">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="d7b80-163">-Exibir geração: Médio, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-163">- View generation: Medium but cached</span></span> <br/> <span data-ttu-id="d7b80-164">-Avaliação a parâmetro: Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-164">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="d7b80-165">-Tradução da consulta: Médio, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-165">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="d7b80-166">-Geração de materializer: Médio, mas em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-166">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="d7b80-167">-Execução de consulta banco de dados: Potencialmente alto (melhor consultas em algumas situações)</span><span class="sxs-lookup"><span data-stu-id="d7b80-167">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="d7b80-168">+ Connection</span><span class="sxs-lookup"><span data-stu-id="d7b80-168">+ Connection.Open</span></span> <br/> <span data-ttu-id="d7b80-169">+ ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="d7b80-169">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="d7b80-170">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="d7b80-170">+ DataReader.Read</span></span> <br/> <span data-ttu-id="d7b80-171">Materialização de objeto: Médio (mais rápido do que o EF5)</span><span class="sxs-lookup"><span data-stu-id="d7b80-171">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="d7b80-172">-Pesquisa identity: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-172">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="d7b80-173">Close</span><span class="sxs-lookup"><span data-stu-id="d7b80-173">Connection.Close</span></span>          | <span data-ttu-id="d7b80-174">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-174">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="d7b80-175">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-175">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="d7b80-176">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-176">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


<span data-ttu-id="d7b80-177">**Segunda execução da consulta – consulta quente**</span><span class="sxs-lookup"><span data-stu-id="d7b80-177">**Second Query Execution – warm query**</span></span>

| <span data-ttu-id="d7b80-178">Gravações de usuário do código</span><span class="sxs-lookup"><span data-stu-id="d7b80-178">Code User Writes</span></span>                                                                                     | <span data-ttu-id="d7b80-179">Ação</span><span class="sxs-lookup"><span data-stu-id="d7b80-179">Action</span></span>                    | <span data-ttu-id="d7b80-180">EF4 Impacto de desempenho</span><span class="sxs-lookup"><span data-stu-id="d7b80-180">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="d7b80-181">EF5 Impacto de desempenho</span><span class="sxs-lookup"><span data-stu-id="d7b80-181">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="d7b80-182">EF6 Impacto de desempenho</span><span class="sxs-lookup"><span data-stu-id="d7b80-182">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="d7b80-183">Criação de contexto</span><span class="sxs-lookup"><span data-stu-id="d7b80-183">Context creation</span></span>          | <span data-ttu-id="d7b80-184">Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-184">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="d7b80-185">Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-185">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="d7b80-186">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-186">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="d7b80-187">Criação de expressão de consulta</span><span class="sxs-lookup"><span data-stu-id="d7b80-187">Query expression creation</span></span> | <span data-ttu-id="d7b80-188">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-188">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="d7b80-189">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-189">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="d7b80-190">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-190">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="d7b80-191">Execução de consulta LINQ</span><span class="sxs-lookup"><span data-stu-id="d7b80-191">LINQ query execution</span></span>      | <span data-ttu-id="d7b80-192">-Metadata ~~Carregando~~ pesquisa: ~~Alta, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-192">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-193">-Exibir ~~geração~~ pesquisa: ~~Potencialmente muito alta, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-193">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-194">-Avaliação a parâmetro: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-194">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="d7b80-195">-Consultar ~~tradução~~ pesquisa: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-195">- Query ~~translation~~ lookup: Medium</span></span> <br/> <span data-ttu-id="d7b80-196">-Materializer ~~geração~~ pesquisa: ~~Médio, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-196">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-197">-Execução de consulta banco de dados: Potencialmente alto</span><span class="sxs-lookup"><span data-stu-id="d7b80-197">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="d7b80-198">+ Connection</span><span class="sxs-lookup"><span data-stu-id="d7b80-198">+ Connection.Open</span></span> <br/> <span data-ttu-id="d7b80-199">+ ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="d7b80-199">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="d7b80-200">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="d7b80-200">+ DataReader.Read</span></span> <br/> <span data-ttu-id="d7b80-201">Materialização de objeto: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-201">Object materialization: Medium</span></span> <br/> <span data-ttu-id="d7b80-202">-Pesquisa identity: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-202">- Identity lookup: Medium</span></span> | <span data-ttu-id="d7b80-203">-Metadata ~~Carregando~~ pesquisa: ~~Alta, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-203">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-204">-Exibir ~~geração~~ pesquisa: ~~Potencialmente muito alta, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-204">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-205">-Avaliação a parâmetro: Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-205">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="d7b80-206">-Consultar ~~tradução~~ pesquisa: ~~Médio, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-206">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-207">-Materializer ~~geração~~ pesquisa: ~~Médio, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-207">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-208">-Execução de consulta banco de dados: Potencialmente alto (melhor consultas em algumas situações)</span><span class="sxs-lookup"><span data-stu-id="d7b80-208">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="d7b80-209">+ Connection</span><span class="sxs-lookup"><span data-stu-id="d7b80-209">+ Connection.Open</span></span> <br/> <span data-ttu-id="d7b80-210">+ ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="d7b80-210">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="d7b80-211">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="d7b80-211">+ DataReader.Read</span></span> <br/> <span data-ttu-id="d7b80-212">Materialização de objeto: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-212">Object materialization: Medium</span></span> <br/> <span data-ttu-id="d7b80-213">-Pesquisa identity: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-213">- Identity lookup: Medium</span></span> | <span data-ttu-id="d7b80-214">-Metadata ~~Carregando~~ pesquisa: ~~Alta, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-214">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-215">-Exibir ~~geração~~ pesquisa: ~~Médio, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-215">- View ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-216">-Avaliação a parâmetro: Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-216">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="d7b80-217">-Consultar ~~tradução~~ pesquisa: ~~Médio, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-217">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-218">-Materializer ~~geração~~ pesquisa: ~~Médio, mas em cache~~ baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-218">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="d7b80-219">-Execução de consulta banco de dados: Potencialmente alto (melhor consultas em algumas situações)</span><span class="sxs-lookup"><span data-stu-id="d7b80-219">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="d7b80-220">+ Connection</span><span class="sxs-lookup"><span data-stu-id="d7b80-220">+ Connection.Open</span></span> <br/> <span data-ttu-id="d7b80-221">+ ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="d7b80-221">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="d7b80-222">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="d7b80-222">+ DataReader.Read</span></span> <br/> <span data-ttu-id="d7b80-223">Materialização de objeto: Médio (mais rápido do que o EF5)</span><span class="sxs-lookup"><span data-stu-id="d7b80-223">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="d7b80-224">-Pesquisa identity: Médio</span><span class="sxs-lookup"><span data-stu-id="d7b80-224">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="d7b80-225">Close</span><span class="sxs-lookup"><span data-stu-id="d7b80-225">Connection.Close</span></span>          | <span data-ttu-id="d7b80-226">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-226">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="d7b80-227">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-227">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="d7b80-228">Baixo</span><span class="sxs-lookup"><span data-stu-id="d7b80-228">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


<span data-ttu-id="d7b80-229">Há várias maneiras para reduzir o custo de desempenho de consultas frios e quentes e vamos dar uma olhada na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="d7b80-229">There are several ways to reduce the performance cost of both cold and warm queries, and we'll take a look at these in the following section.</span></span> <span data-ttu-id="d7b80-230">Especificamente, vamos examinar reduzindo o custo de carregamento em consultas cold usando modos de exibição gerados previamente, que devem ajudar a minimizar problemas de desempenho durante a geração de exibição do modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-230">Specifically, we'll look at reducing the cost of model loading in cold queries by using pre-generated views, which should help alleviate performance pains experienced during view generation.</span></span> <span data-ttu-id="d7b80-231">Para consultas passivos, abordaremos o cache de plano de consulta, nenhuma consulta de acompanhamento e opções de execução de consulta diferentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-231">For warm queries, we'll cover query plan caching, no tracking queries, and different query execution options.</span></span>

### <a name="21-what-is-view-generation"></a><span data-ttu-id="d7b80-232">2.1 o que é a geração de exibição?</span><span class="sxs-lookup"><span data-stu-id="d7b80-232">2.1 What is View Generation?</span></span>

<span data-ttu-id="d7b80-233">Para entender qual exibição geração é, precisamos primeiro compreender quais são os "Modos de exibição de mapeamento".</span><span class="sxs-lookup"><span data-stu-id="d7b80-233">In order to understand what view generation is, we must first understand what “Mapping Views” are.</span></span> <span data-ttu-id="d7b80-234">Modos de exibição de mapeamento são representações executáveis das transformações especificadas no mapeamento para cada conjunto de entidades e a associação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-234">Mapping Views are executable representations of the transformations specified in the mapping for each entity set and association.</span></span> <span data-ttu-id="d7b80-235">Internamente, esses modos de exibição de mapeamento levam a forma de CQTs (árvores canônicas consulta).</span><span class="sxs-lookup"><span data-stu-id="d7b80-235">Internally, these mapping views take the shape of CQTs (canonical query trees).</span></span> <span data-ttu-id="d7b80-236">Há dois tipos de modos de exibição de mapeamento:</span><span class="sxs-lookup"><span data-stu-id="d7b80-236">There are two types of mapping views:</span></span>

-   <span data-ttu-id="d7b80-237">Modos de exibição de consulta: representam a transformação necessária para o esquema de banco de dados para o modelo conceitual.</span><span class="sxs-lookup"><span data-stu-id="d7b80-237">Query views: these represent the transformation necessary to go from the database schema to the conceptual model.</span></span>
-   <span data-ttu-id="d7b80-238">Atualizar modos de exibição: representam a transformação necessária ir do modelo conceitual para o esquema de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-238">Update views: these represent the transformation necessary to go from the conceptual model to the database schema.</span></span>

<span data-ttu-id="d7b80-239">Tenha em mente que o modelo conceitual pode ser diferente do esquema de banco de dados de várias maneiras.</span><span class="sxs-lookup"><span data-stu-id="d7b80-239">Keep in mind that the conceptual model might differ from the database schema in various ways.</span></span> <span data-ttu-id="d7b80-240">Por exemplo, uma única tabela pode ser usada para armazenar os dados para dois tipos de entidade diferentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-240">For example, one single table might be used to store the data for two different entity types.</span></span> <span data-ttu-id="d7b80-241">Herança e não triviais mapeamentos desempenham um papel na complexidade das exibições de mapeamento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-241">Inheritance and non-trivial mappings play a role in the complexity of the mapping views.</span></span>

<span data-ttu-id="d7b80-242">O processo de computação esses modos de exibição baseados na especificação do mapeamento é o que chamamos de geração de exibição.</span><span class="sxs-lookup"><span data-stu-id="d7b80-242">The process of computing these views based on the specification of the mapping is what we call view generation.</span></span> <span data-ttu-id="d7b80-243">Geração de exibição ou podem ocorrer dinamicamente quando um modelo é carregado, ou em tempo de compilação, usando "exibições pré-geradas"; o último é serializado na forma de instruções SQL de entidade para a C\# ou arquivo do VB.</span><span class="sxs-lookup"><span data-stu-id="d7b80-243">View generation can either take place dynamically when a model is loaded, or at build time, by using "pre-generated views"; the latter are serialized in the form of Entity SQL statements to a C\# or VB file.</span></span>

<span data-ttu-id="d7b80-244">Quando os modos de exibição são gerados, eles também são validados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-244">When views are generated, they are also validated.</span></span> <span data-ttu-id="d7b80-245">Do ponto de vista do desempenho, a grande maioria do custo de geração de exibição é, na verdade, a validação dos modos de exibição que garante que as conexões entre as entidades fazem sentido e tenham a cardinalidade correta para todas as operações com suporte.</span><span class="sxs-lookup"><span data-stu-id="d7b80-245">From a performance standpoint, the vast majority of the cost of view generation is actually the validation of the views which ensures that the connections between the entities make sense and have the correct cardinality for all the supported operations.</span></span>

<span data-ttu-id="d7b80-246">Quando uma consulta ao longo de um conjunto de entidades é executada, a consulta é combinada com o modo de exibição de consulta correspondente, e o resultado dessa composição é executado por meio do compilador plano para criar a representação da consulta que o repositório de backup possa entender.</span><span class="sxs-lookup"><span data-stu-id="d7b80-246">When a query over an entity set is executed, the query is combined with the corresponding query view, and the result of this composition is run through the plan compiler to create the representation of the query that the backing store can understand.</span></span> <span data-ttu-id="d7b80-247">Para o SQL Server, o resultado final desta compilação será uma instrução T-SQL SELECT.</span><span class="sxs-lookup"><span data-stu-id="d7b80-247">For SQL Server, the final result of this compilation will be a T-SQL SELECT statement.</span></span> <span data-ttu-id="d7b80-248">Na primeira vez em que uma atualização sobre um conjunto de entidades é executada, o modo de exibição de atualização é executado por meio de um processo semelhante para transformá-lo em instruções DML para o banco de dados de destino.</span><span class="sxs-lookup"><span data-stu-id="d7b80-248">The first time an update over an entity set is performed, the update view is run through a similar process to transform it into DML statements for the target database.</span></span>

### <a name="22-factors-that-affect-view-generation-performance"></a><span data-ttu-id="d7b80-249">2.2 fatores que afetam o desempenho de geração de exibição</span><span class="sxs-lookup"><span data-stu-id="d7b80-249">2.2 Factors that affect View Generation performance</span></span>

<span data-ttu-id="d7b80-250">O desempenho da etapa de geração de exibição depende não apenas o tamanho do seu modelo mas também interconectados como o modelo é.</span><span class="sxs-lookup"><span data-stu-id="d7b80-250">The performance of view generation step not only depends on the size of your model but also on how interconnected the model is.</span></span> <span data-ttu-id="d7b80-251">Se duas entidades são conectadas por meio de uma cadeia de herança ou uma associação, eles devem estar conectados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-251">If two Entities are connected via an inheritance chain or an Association, they are said to be connected.</span></span> <span data-ttu-id="d7b80-252">Da mesma forma, se duas tabelas estão conectadas por meio de uma chave estrangeira, eles estão conectados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-252">Similarly if two tables are connected via a foreign key, they are connected.</span></span> <span data-ttu-id="d7b80-253">À medida que aumenta o número de entidades de conectados e tabelas em seus esquemas, a geração de exibição custo aumenta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-253">As the number of connected Entities and tables in your schemas increase, the view generation cost increases.</span></span>

<span data-ttu-id="d7b80-254">O algoritmo que usamos para gerar e validar os modos de exibição é exponencial no pior caso, embora, podemos usar algumas otimizações para melhorar isso.</span><span class="sxs-lookup"><span data-stu-id="d7b80-254">The algorithm that we use to generate and validate views is exponential in the worst case, though we do use some optimizations to improve this.</span></span> <span data-ttu-id="d7b80-255">Os principais fatores que parecem afetar negativamente o desempenho são:</span><span class="sxs-lookup"><span data-stu-id="d7b80-255">The biggest factors that seem to negatively affect performance are:</span></span>

-   <span data-ttu-id="d7b80-256">Tamanho do modelo, referindo-se ao número de entidades e a quantidade de associações entre essas entidades.</span><span class="sxs-lookup"><span data-stu-id="d7b80-256">Model size, referring to the number of entities and the amount of associations between these entities.</span></span>
-   <span data-ttu-id="d7b80-257">Complexidade de modelos, especificamente a herança que envolvem um grande número de tipos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-257">Model complexity, specifically inheritance involving a large number of types.</span></span>
-   <span data-ttu-id="d7b80-258">Usando associações independente, em vez de associações de chave estrangeira.</span><span class="sxs-lookup"><span data-stu-id="d7b80-258">Using Independent Associations, instead of Foreign Key Associations.</span></span>

<span data-ttu-id="d7b80-259">Para modelos pequenos e simples, o custo pode ser pequeno o suficiente para não perder tempo com isso usando as exibições pré-geradas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-259">For small, simple models the cost may be small enough to not bother using pre-generated views.</span></span> <span data-ttu-id="d7b80-260">À medida que aumentam de tamanho do modelo e a complexidade, há várias opções disponíveis para reduzir o custo de geração de exibição e a validação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-260">As model size and complexity increase, there are several options available to reduce the cost of view generation and validation.</span></span>

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a><span data-ttu-id="d7b80-261">2.3 usando Pre-Generated modos de exibição para diminuir o modelo de tempo de carregamento</span><span class="sxs-lookup"><span data-stu-id="d7b80-261">2.3 Using Pre-Generated Views to decrease model load time</span></span>

<span data-ttu-id="d7b80-262">Para obter informações detalhadas sobre como usar exibições pré-gerados no Entity Framework 6, visite [Pre-Generated modos de exibição de mapeamento](~/ef6/fundamentals/performance/pre-generated-views.md)</span><span class="sxs-lookup"><span data-stu-id="d7b80-262">For detailed information on how to use pre-generated views on Entity Framework 6 visit [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md)</span></span>

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a><span data-ttu-id="d7b80-263">2.3.1 exibições pré-geradas usando o Entity Framework Power Tools Community Edition</span><span class="sxs-lookup"><span data-stu-id="d7b80-263">2.3.1 Pre-Generated views using the Entity Framework Power Tools Community Edition</span></span>

<span data-ttu-id="d7b80-264">Você pode usar o [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) para gerar exibições dos modelos EDMX e o Code First clicando duas vezes o arquivo de classe de modelo e usando o menu do Entity Framework para selecionar "Gerar exibições".</span><span class="sxs-lookup"><span data-stu-id="d7b80-264">You can use the [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) to generate views of EDMX and Code First models by right-clicking the model class file and using the Entity Framework menu to select “Generate Views”.</span></span> <span data-ttu-id="d7b80-265">O Entity Framework Power Tools Community Edition funcionam somente em contextos derivada de DbContext.</span><span class="sxs-lookup"><span data-stu-id="d7b80-265">The Entity Framework Power Tools Community Edition work only on DbContext-derived contexts.</span></span>

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a><span data-ttu-id="d7b80-266">2.3.2 como usar exibições pré-geradas com um modelo criado pelo EDMGen</span><span class="sxs-lookup"><span data-stu-id="d7b80-266">2.3.2 How to use Pre-generated views with a model created by EDMGen</span></span>

<span data-ttu-id="d7b80-267">EDMGen é um utilitário que é fornecido com o .NET e funciona com o Entity Framework 4 e 5, mas não com o Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="d7b80-267">EDMGen is a utility that ships with .NET and works with Entity Framework 4 and 5, but not with Entity Framework 6.</span></span> <span data-ttu-id="d7b80-268">EDMGen permite que você gere um arquivo de modelo, a camada de objeto e os modos de exibição da linha de comando.</span><span class="sxs-lookup"><span data-stu-id="d7b80-268">EDMGen allows you to generate a model file, the object layer and the views from the command line.</span></span> <span data-ttu-id="d7b80-269">Uma das saídas será um arquivo de modos de exibição em seu idioma de preferência, VB ou C\#.</span><span class="sxs-lookup"><span data-stu-id="d7b80-269">One of the outputs will be a Views file in your language of choice, VB or C\#.</span></span> <span data-ttu-id="d7b80-270">Este é um arquivo de código que contém trechos de código do Entity SQL para cada conjunto de entidades.</span><span class="sxs-lookup"><span data-stu-id="d7b80-270">This is a code file containing Entity SQL snippets for each entity set.</span></span> <span data-ttu-id="d7b80-271">Para habilitar exibições pré-geradas, basta incluir o arquivo em seu projeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-271">To enable pre-generated views, you simply include the file in your project.</span></span>

<span data-ttu-id="d7b80-272">Se você fizer edições manualmente os arquivos de esquema para o modelo, será preciso gerar novamente o arquivo de modos de exibição.</span><span class="sxs-lookup"><span data-stu-id="d7b80-272">If you manually make edits to the schema files for the model, you will need to re-generate the views file.</span></span> <span data-ttu-id="d7b80-273">Você pode fazer isso executando EDMGen com o **/mode:ViewGeneration** sinalizador.</span><span class="sxs-lookup"><span data-stu-id="d7b80-273">You can do this by running EDMGen with the **/mode:ViewGeneration** flag.</span></span>

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a><span data-ttu-id="d7b80-274">2.3.3 como usar exibições Pre-Generated com um arquivo EDMX</span><span class="sxs-lookup"><span data-stu-id="d7b80-274">2.3.3 How to use Pre-Generated Views with an EDMX file</span></span>

<span data-ttu-id="d7b80-275">Você também pode usar o EDMGen para gerar os modos de exibição para um arquivo EDMX - tópico do MSDN mencionado anteriormente descreve como adicionar um evento de pré-compilação para fazer isso, mas isso é complicado e há alguns casos em que não é possível.</span><span class="sxs-lookup"><span data-stu-id="d7b80-275">You can also use EDMGen to generate views for an EDMX file - the previously referenced MSDN topic describes how to add a pre-build event to do this - but this is complicated and there are some cases where it isn't possible.</span></span> <span data-ttu-id="d7b80-276">É geralmente mais fácil usar um modelo T4 para gerar os modos de exibição quando o modelo estiver em um arquivo edmx.</span><span class="sxs-lookup"><span data-stu-id="d7b80-276">It's generally easier to use a T4 template to generate the views when your model is in an edmx file.</span></span>

<span data-ttu-id="d7b80-277">Blog da equipe do ADO.NET tem uma postagem que descreve como usar um modelo T4 para geração de exibição ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span><span class="sxs-lookup"><span data-stu-id="d7b80-277">The ADO.NET team blog has a post that describes how to use a T4 template for view generation ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span></span> <span data-ttu-id="d7b80-278">Esta postagem inclui um modelo que pode ser baixado e adicionado ao seu projeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-278">This post includes a template that can be downloaded and added to your project.</span></span> <span data-ttu-id="d7b80-279">O modelo foi gravado para a primeira versão do Entity Framework, portanto, eles não são garantidos para trabalhar com as versões mais recentes do Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="d7b80-279">The template was written for the first version of Entity Framework, so they aren’t guaranteed to work with the latest versions of Entity Framework.</span></span> <span data-ttu-id="d7b80-280">No entanto, você pode baixar um conjunto de modelos de geração de exibição mais atualizado para o Entity Framework 4 e 5from Galeria do Visual Studio:</span><span class="sxs-lookup"><span data-stu-id="d7b80-280">However, you can download a more up-to-date set of view generation templates for Entity Framework 4 and 5from the Visual Studio Gallery:</span></span>

-   <span data-ttu-id="d7b80-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span><span class="sxs-lookup"><span data-stu-id="d7b80-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span></span>
-   <span data-ttu-id="d7b80-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span><span class="sxs-lookup"><span data-stu-id="d7b80-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span></span>

<span data-ttu-id="d7b80-283">Se você estiver usando o Entity Framework 6 você pode obter a exibição de modelos de geração de T4 da Galeria do Visual Studio no \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-283">If you’re using Entity Framework 6 you can get the view generation T4 templates from the Visual Studio Gallery at \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span></span>

### <a name="24-reducing-the-cost-of-view-generation"></a><span data-ttu-id="d7b80-284">2.4 reduzindo o custo de geração de exibição</span><span class="sxs-lookup"><span data-stu-id="d7b80-284">2.4 Reducing the cost of view generation</span></span>

<span data-ttu-id="d7b80-285">Usar exibições pré-geradas move o custo de geração de exibição do modelo de carregamento (tempo de execução) para tempo de design.</span><span class="sxs-lookup"><span data-stu-id="d7b80-285">Using pre-generated views moves the cost of view generation from model loading (run time) to design time.</span></span> <span data-ttu-id="d7b80-286">Enquanto isso melhora o desempenho de inicialização em tempo de execução, você ainda terá a dificuldade de geração de exibição enquanto você está desenvolvendo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-286">While this improves startup performance at runtime, you will still experience the pain of view generation while you are developing.</span></span> <span data-ttu-id="d7b80-287">Há várias outras dicas e truques que podem ajudar a reduzir o custo de geração de exibição, em tempo de compilação e tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="d7b80-287">There are several additional tricks that can help reduce the cost of view generation, both at compile time and run time.</span></span>

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a><span data-ttu-id="d7b80-288">2.4.1 usando as associações de chave estrangeira para reduzir o custo de geração de exibição</span><span class="sxs-lookup"><span data-stu-id="d7b80-288">2.4.1 Using Foreign Key Associations to reduce view generation cost</span></span>

<span data-ttu-id="d7b80-289">Temos visto um número de casos em que a troca as associações no modelo de associações independente para as associações de chave estrangeira drasticamente aprimorado o tempo gasto na geração de exibição.</span><span class="sxs-lookup"><span data-stu-id="d7b80-289">We have seen a number of cases where switching the associations in the model from Independent Associations to Foreign Key Associations dramatically improved the time spent in view generation.</span></span>

<span data-ttu-id="d7b80-290">Para demonstrar essa melhoria, geramos duas versões do modelo Navision usando EDMGen.</span><span class="sxs-lookup"><span data-stu-id="d7b80-290">To demonstrate this improvement, we generated two versions of the Navision model by using EDMGen.</span></span> <span data-ttu-id="d7b80-291">*Observação: consulte o Apêndice C para obter uma descrição do modelo Navision.*</span><span class="sxs-lookup"><span data-stu-id="d7b80-291">*Note: see appendix C for a description of the Navision model.*</span></span> <span data-ttu-id="d7b80-292">O modelo Navision é interessante para este exercício devido a sua quantidade muito grande de entidades e relações entre eles.</span><span class="sxs-lookup"><span data-stu-id="d7b80-292">The Navision model is interesting for this exercise due to its very large amount of entities and relationships between them.</span></span>

<span data-ttu-id="d7b80-293">Uma versão desse modelo muito grandes foi gerada com associações de chaves estrangeiras e outro foi gerado com associações independentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-293">One version of this very large model was generated with Foreign Keys Associations and the other was generated with Independent Associations.</span></span> <span data-ttu-id="d7b80-294">Podemos então atingiu o tempo quanto tempo levou para gerar os modos de exibição para cada modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-294">We then timed how long it took to generate the views for each model.</span></span> <span data-ttu-id="d7b80-295">Teste do Entity Framework 5 usado o método GenerateViews() da classe EntityViewGenerator para gerar os modos de exibição, enquanto o teste do Entity Framework 6 usou o método GenerateViews() da classe StorageMappingItemCollection.</span><span class="sxs-lookup"><span data-stu-id="d7b80-295">Entity Framework 5 test used the GenerateViews() method from class EntityViewGenerator to generate the views, while the Entity Framework 6 test used the GenerateViews() method from class StorageMappingItemCollection.</span></span> <span data-ttu-id="d7b80-296">Isso devido a reestruturação do código que ocorreram na Base de código do Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="d7b80-296">This due to code restructuring that occurred in the Entity Framework 6 codebase.</span></span>

<span data-ttu-id="d7b80-297">Usando o Entity Framework 5, geração de exibição para o modelo com chaves estrangeiras levou 65 minutos em um computador de laboratório.</span><span class="sxs-lookup"><span data-stu-id="d7b80-297">Using Entity Framework 5, view generation for the model with Foreign Keys took 65 minutes in a lab machine.</span></span> <span data-ttu-id="d7b80-298">Sabe quanto seria necessário para gerar os modos de exibição para o modelo que usado associações independentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-298">It's unknown how long it would have taken to generate the views for the model that used independent associations.</span></span> <span data-ttu-id="d7b80-299">Deixamos que o teste em execução por mais de um mês antes do computador foi reinicializado em nosso laboratório para instalar atualizações mensais.</span><span class="sxs-lookup"><span data-stu-id="d7b80-299">We left the test running for over a month before the machine was rebooted in our lab to install monthly updates.</span></span>

<span data-ttu-id="d7b80-300">Usando o Entity Framework 6, geração de exibição para o modelo com chaves estrangeiras levou 28 segundos no mesmo computador do laboratório.</span><span class="sxs-lookup"><span data-stu-id="d7b80-300">Using Entity Framework 6, view generation for the model with Foreign Keys took 28 seconds in the same lab machine.</span></span> <span data-ttu-id="d7b80-301">Geração de exibição para o modelo que usa associações independentes levou 58 segundos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-301">View generation for the model that uses Independent Associations took 58 seconds.</span></span> <span data-ttu-id="d7b80-302">As melhorias feitas para o Entity Framework 6 em seu código de geração de exibição significam que muitos projetos não será necessário pré-gerado modos de exibição para obter tempos de inicialização mais rápidos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-302">The improvements done to Entity Framework 6 on its view generation code mean that many projects won’t need pre-generated views to obtain faster startup times.</span></span>

<span data-ttu-id="d7b80-303">É importante para o comentário de gerar previamente exibições no Entity Framework 4 e 5 pode ser feito com o Entity Framework Power Tools ou o EDMGen.</span><span class="sxs-lookup"><span data-stu-id="d7b80-303">It’s important to remark that pre-generating views in Entity Framework 4 and 5 can be done with EDMGen or the Entity Framework Power Tools.</span></span> <span data-ttu-id="d7b80-304">Para o modo de exibição do Entity Framework 6 geração pode ser feita por meio do Entity Framework Power Tools ou programaticamente, conforme descrito em [modos de exibição de mapeamento Pre-Generated](~/ef6/fundamentals/performance/pre-generated-views.md).</span><span class="sxs-lookup"><span data-stu-id="d7b80-304">For Entity Framework 6 view generation can be done via the Entity Framework Power Tools or programmatically as described in [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md).</span></span>

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a><span data-ttu-id="d7b80-305">2.4.1.1 como usar chaves estrangeiras em vez de associações independentes</span><span class="sxs-lookup"><span data-stu-id="d7b80-305">2.4.1.1 How to use Foreign Keys instead of Independent Associations</span></span>

<span data-ttu-id="d7b80-306">Ao usar o EDMGen ou Entity Designer no Visual Studio, você obtém FKs por padrão, e demora apenas uma única sinalização de caixa de seleção ou a linha de comando para alternar entre FKs e IAs.</span><span class="sxs-lookup"><span data-stu-id="d7b80-306">When using EDMGen or the Entity Designer in Visual Studio, you get FKs by default, and it only takes a single checkbox or command line flag to switch between FKs and IAs.</span></span>

<span data-ttu-id="d7b80-307">Se você tiver um grande modelo Code First, usando associações independentes terá o mesmo efeito sobre a geração de exibição.</span><span class="sxs-lookup"><span data-stu-id="d7b80-307">If you have a large Code First model, using Independent Associations will have the same effect on view generation.</span></span> <span data-ttu-id="d7b80-308">Você pode evitar esse impacto, incluindo propriedades de chave estrangeira nas classes para seus objetos dependentes, embora alguns desenvolvedores considerará como ser poluir seu modelo de objeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-308">You can avoid this impact by including Foreign Key properties on the classes for your dependent objects, though some developers will consider this to be polluting their object model.</span></span> <span data-ttu-id="d7b80-309">Você pode encontrar mais informações sobre esse assunto \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-309">You can find more information on this subject in \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span></span>

| <span data-ttu-id="d7b80-310">Ao usar</span><span class="sxs-lookup"><span data-stu-id="d7b80-310">When using</span></span>      | <span data-ttu-id="d7b80-311">Faça isto</span><span class="sxs-lookup"><span data-stu-id="d7b80-311">Do this</span></span>                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="d7b80-312">Entity Designer</span><span class="sxs-lookup"><span data-stu-id="d7b80-312">Entity Designer</span></span> | <span data-ttu-id="d7b80-313">Depois de adicionar uma associação entre duas entidades, verifique se que você tem uma restrição referencial.</span><span class="sxs-lookup"><span data-stu-id="d7b80-313">After adding an association between two entities, make sure you have a referential constraint.</span></span> <span data-ttu-id="d7b80-314">Restrições referenciais informar ao Entity Framework para usar as chaves estrangeiras em vez de associações independentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-314">Referential constraints tell Entity Framework to use Foreign Keys instead of Independent Associations.</span></span> <span data-ttu-id="d7b80-315">Para obter mais detalhes, visite \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-315">For additional details visit \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span></span> |
| <span data-ttu-id="d7b80-316">EDMGen</span><span class="sxs-lookup"><span data-stu-id="d7b80-316">EDMGen</span></span>          | <span data-ttu-id="d7b80-317">Ao usar o EDMGen para gerar os arquivos do banco de dados, suas chaves estrangeiras serão respeitadas e adicionados como tal no modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-317">When using EDMGen to generate your files from the database, your Foreign Keys will be respected and added to the model as such.</span></span> <span data-ttu-id="d7b80-318">Para obter mais informações sobre as diferentes opções expostas pelo EDMGen visite [ http://msdn.microsoft.com/library/bb387165.aspx ](https://msdn.microsoft.com/library/bb387165.aspx).</span><span class="sxs-lookup"><span data-stu-id="d7b80-318">For more information on the different options exposed by EDMGen visit [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span></span>                           |
| <span data-ttu-id="d7b80-319">Code First</span><span class="sxs-lookup"><span data-stu-id="d7b80-319">Code First</span></span>      | <span data-ttu-id="d7b80-320">Consulte a seção "Relação convenção" a [convenções de Code First](~/ef6/modeling/code-first/conventions/built-in.md) tópico para obter informações sobre como incluir propriedades de chave estrangeira em objetos dependentes ao usar o Code First.</span><span class="sxs-lookup"><span data-stu-id="d7b80-320">See the "Relationship Convention" section of the [Code First Conventions](~/ef6/modeling/code-first/conventions/built-in.md) topic for information on how to include foreign key properties on dependent objects when using Code First.</span></span>                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a><span data-ttu-id="d7b80-321">2.4.2 movendo seu modelo para um assembly separado</span><span class="sxs-lookup"><span data-stu-id="d7b80-321">2.4.2 Moving your model to a separate assembly</span></span>

<span data-ttu-id="d7b80-322">Quando seu modelo está incluído diretamente no projeto do seu aplicativo e você gera exibições por meio de um evento de pré-Build ou de um modelo T4, geração de exibição e a validação ocorrerá sempre que o projeto for recriado, mesmo se o modelo não foi alterado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-322">When your model is included directly in your application's project and you generate views through a pre-build event or a T4 template, view generation and validation will take place whenever the project is rebuilt, even if the model wasn't changed.</span></span> <span data-ttu-id="d7b80-323">Se você move o modelo para um assembly separado e referenciá-lo no projeto do seu aplicativo, você pode fazer outras alterações ao seu aplicativo sem a necessidade de recompilar o projeto que contém o modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-323">If you move the model to a separate assembly and reference it from your application's project, you can make other changes to your application without needing to rebuild the project containing the model.</span></span>

<span data-ttu-id="d7b80-324">*Observação:*  ao mover seu modelo para separar os assemblies Lembre-se de copiar as cadeias de caracteres de conexão para o modelo para o arquivo de configuração de aplicativo do projeto do cliente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-324">*Note:*  when moving your model to separate assemblies remember to copy the connection strings for the model into the application configuration file of the client project.</span></span>

#### <a name="243-disable-validation-of-an-edmx-based-model"></a><span data-ttu-id="d7b80-325">2.4.3 desabilitar a validação de um modelo baseado em edmx</span><span class="sxs-lookup"><span data-stu-id="d7b80-325">2.4.3 Disable validation of an edmx-based model</span></span>

<span data-ttu-id="d7b80-326">Modelos EDMX são validados em tempo de compilação, mesmo se o modelo permanece inalterado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-326">EDMX models are validated at compile time, even if the model is unchanged.</span></span> <span data-ttu-id="d7b80-327">Se já tiver sido validado seu modelo, você pode suprimir a validação em tempo de compilação, definindo a propriedade "Validar na compilação" como false na janela Propriedades.</span><span class="sxs-lookup"><span data-stu-id="d7b80-327">If your model has already been validated, you can suppress validation at compile time by setting the "Validate on Build" property to false in the properties window.</span></span> <span data-ttu-id="d7b80-328">Quando você alterar o mapeamento ou modelo, você pode temporariamente reativar validação para verificar suas alterações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-328">When you change your mapping or model, you can temporarily re-enable validation to verify your changes.</span></span>

<span data-ttu-id="d7b80-329">Observe que foram feitas melhorias de desempenho para o Entity Framework Designer para o Entity Framework 6 e o custo do "validar na compilação" é muito menor do que nas versões anteriores do designer.</span><span class="sxs-lookup"><span data-stu-id="d7b80-329">Note that performance improvements were made to the Entity Framework Designer for Entity Framework 6, and the cost of the “Validate on Build” is much lower than in previous versions of the designer.</span></span>

## <a name="3-caching-in-the-entity-framework"></a><span data-ttu-id="d7b80-330">Cache de 3 no Entity Framework</span><span class="sxs-lookup"><span data-stu-id="d7b80-330">3 Caching in the Entity Framework</span></span>

<span data-ttu-id="d7b80-331">O Entity Framework tem os seguintes formulários de cache interno:</span><span class="sxs-lookup"><span data-stu-id="d7b80-331">Entity Framework has the following forms of caching built-in:</span></span>

1.  <span data-ttu-id="d7b80-332">Cache de objeto – ObjectStateManager incorporado a uma instância de ObjectContext mantém o controle na memória dos objetos que foram recuperados usando essa instância.</span><span class="sxs-lookup"><span data-stu-id="d7b80-332">Object caching – the ObjectStateManager built into an ObjectContext instance keeps track in memory of the objects that have been retrieved using that instance.</span></span> <span data-ttu-id="d7b80-333">Isso também é conhecido como cache de primeiro nível.</span><span class="sxs-lookup"><span data-stu-id="d7b80-333">This is also known as first-level cache.</span></span>
2.  <span data-ttu-id="d7b80-334">Cache de plano de consulta - reutilizando o comando de armazenamento gerado quando uma consulta é executada mais de uma vez.</span><span class="sxs-lookup"><span data-stu-id="d7b80-334">Query Plan Caching - reusing the generated store command when a query is executed more than once.</span></span>
3.  <span data-ttu-id="d7b80-335">Metadados de cache – compartilhando os metadados para um modelo entre diferentes conexões com o mesmo modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-335">Metadata caching - sharing the metadata for a model across different connections to the same model.</span></span>

<span data-ttu-id="d7b80-336">Além de caches de que o EF oferece fora da caixa, um tipo especial de provedor de dados ADO.NET conhecido como um provedor de encapsulamento também pode ser usado para estender o Entity Framework com um cache para resultados recuperados do banco de dados, também conhecido como cache de segundo nível.</span><span class="sxs-lookup"><span data-stu-id="d7b80-336">Besides the caches that EF provides out of the box, a special kind of ADO.NET data provider known as a wrapping provider can also be used to extend Entity Framework with a cache for the results retrieved from the database, also known as second-level caching.</span></span>

### <a name="31-object-caching"></a><span data-ttu-id="d7b80-337">3.1 do objeto de cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-337">3.1 Object Caching</span></span>

<span data-ttu-id="d7b80-338">Por padrão quando uma entidade for retornada nos resultados de uma consulta, antes do EF materializa, ObjectContext verificará se uma entidade com a mesma chave já foi carregada em seu ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="d7b80-338">By default when an entity is returned in the results of a query, just before EF materializes it, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span></span> <span data-ttu-id="d7b80-339">Se já houver uma entidade com as mesmas chaves EF incluirá nos resultados da consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-339">If an entity with the same keys is already present EF will include it in the results of the query.</span></span> <span data-ttu-id="d7b80-340">Embora o EF ainda emitir a consulta no banco de dados, esse comportamento pode ignorar grande parte do custo de materializar a entidade várias vezes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-340">Although EF will still issue the query against the database, this behavior can bypass much of the cost of materializing the entity multiple times.</span></span>

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a><span data-ttu-id="d7b80-341">3.1.1 Obtendo entidades do cache de objetos usando DbContext localizar</span><span class="sxs-lookup"><span data-stu-id="d7b80-341">3.1.1 Getting entities from the object cache using DbContext Find</span></span>

<span data-ttu-id="d7b80-342">Ao contrário de uma consulta regular, o método Find no DbSet (APIs incluídas pela primeira vez no EF 4.1) executará uma pesquisa na memória antes de emitir até mesmo a consulta no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-342">Unlike a regular query, the Find method in DbSet (APIs included for the first time in EF 4.1) will perform a search in memory before even issuing the query against the database.</span></span> <span data-ttu-id="d7b80-343">É importante observar que duas instâncias diferentes do ObjectContext terá duas instâncias diferentes de ObjectStateManager, significando que elas têm os caches do objeto separado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-343">It’s important to note that two different ObjectContext instances will have two different ObjectStateManager instances, meaning that they have separate object caches.</span></span>

<span data-ttu-id="d7b80-344">Localizar usa o valor de chave primária para tentar encontrar uma entidade acompanhada pelo contexto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-344">Find uses the primary key value to attempt to find an entity tracked by the context.</span></span> <span data-ttu-id="d7b80-345">Se a entidade não está no contexto, em seguida, uma consulta será executada e avaliada no banco de dados e null será retornado se a entidade não for encontrada no contexto ou no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-345">If the entity is not in the context then a query will be executed and evaluated against the database, and null is returned if the entity is not found in the context or in the database.</span></span> <span data-ttu-id="d7b80-346">Observe que localizar também retorna as entidades que foram adicionadas ao contexto, mas ainda não foi salvo no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-346">Note that Find also returns entities that have been added to the context but have not yet been saved to the database.</span></span>

<span data-ttu-id="d7b80-347">Há uma consideração de desempenho a ser tomada quando o uso de Find.</span><span class="sxs-lookup"><span data-stu-id="d7b80-347">There is a performance consideration to be taken when using Find.</span></span> <span data-ttu-id="d7b80-348">Chamadas para esse método por padrão irá disparar uma validação de cache de objetos para detectar alterações ainda aguardando confirmação no banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-348">Invocations to this method by default will trigger a validation of the object cache in order to detect changes that are still pending commit to the database.</span></span> <span data-ttu-id="d7b80-349">Esse processo pode ser muito caro, se houver um número muito grande de objetos no cache de objetos ou em um gráfico de objeto grande, que está sendo adicionado ao cache de objeto, mas também pode ser desabilitado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-349">This process can be very expensive if there are a very large number of objects in the object cache or in a large object graph being added to the object cache, but it can also be disabled.</span></span> <span data-ttu-id="d7b80-350">Em alguns casos, você pode perceber sobre uma ordem de magnitude de diferença na chamada de localizar o método quando você desabilita automaticamente detectar alterações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-350">In certain cases, you may perceive over an order of magnitude of difference in calling the Find method when you disable auto detect changes.</span></span> <span data-ttu-id="d7b80-351">Ainda, uma segunda ordem de magnitude é percebida quando, na verdade, o objeto está no cache versus quando o objeto tem a ser recuperado do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-351">Yet a second order of magnitude is perceived when the object actually is in the cache versus when the object has to be retrieved from the database.</span></span> <span data-ttu-id="d7b80-352">Aqui está um exemplo de grafo com medidas calculadas usando alguns dos nossos microbenchmarks, expressada em milissegundos, com uma carga de 5000 entidades:</span><span class="sxs-lookup"><span data-stu-id="d7b80-352">Here is an example graph with measurements taken using some of our microbenchmarks, expressed in milliseconds, with a load of 5000 entities:</span></span>

<span data-ttu-id="d7b80-353">![Escala logarítmica do .NET 4.5](~/ef6/media/net45logscale.png ".NET 4.5 – escala logarítmica")</span><span class="sxs-lookup"><span data-stu-id="d7b80-353">![.NET 4.5 logarithmic scale](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmic scale")</span></span>

<span data-ttu-id="d7b80-354">Exemplo de localização com alterações de detecção automática desabilitada:</span><span class="sxs-lookup"><span data-stu-id="d7b80-354">Example of Find with auto-detect changes disabled:</span></span>

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

<span data-ttu-id="d7b80-355">O que você deve considerar ao usar o método Find é:</span><span class="sxs-lookup"><span data-stu-id="d7b80-355">What you have to consider when using the Find method is:</span></span>

1.  <span data-ttu-id="d7b80-356">Se o objeto não está em cache os benefícios de localização são negados, mas a sintaxe é ainda mais simples do que uma consulta pela chave.</span><span class="sxs-lookup"><span data-stu-id="d7b80-356">If the object is not in the cache the benefits of Find are negated, but the syntax is still simpler than a query by key.</span></span>
2.  <span data-ttu-id="d7b80-357">Se as alterações de detecção automática está habilitada o custo do método Find pode aumentar em uma ordem de magnitude ou ainda mais, dependendo da complexidade do seu modelo e a quantidade de entidades em seu cache de objeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-357">If auto detect changes is enabled the cost of the Find method may increase by one order of magnitude, or even more depending on the complexity of your model and the amount of entities in your object cache.</span></span>

<span data-ttu-id="d7b80-358">Além disso, tenha em mente que encontrar apenas retorna a entidade que você está procurando e ele faz automaticamente carrega suas entidades associadas se elas não ainda estiverem no cache de objetos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-358">Also, keep in mind that Find only returns the entity you are looking for and it does not automatically loads its associated entities if they are not already in the object cache.</span></span> <span data-ttu-id="d7b80-359">Se você precisar recuperar entidades associadas, você pode usar uma consulta por chave com o carregamento adiantado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-359">If you need to retrieve associated entities, you can use a query by key with eager loading.</span></span> <span data-ttu-id="d7b80-360">Para obter mais informações, consulte **8.1 vs o carregamento lento. O carregamento adiantado**.</span><span class="sxs-lookup"><span data-stu-id="d7b80-360">For more information see **8.1 Lazy Loading vs. Eager Loading**.</span></span>

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a><span data-ttu-id="d7b80-361">3.1.2 problemas de desempenho de quando o cache de objetos tem muitas entidades</span><span class="sxs-lookup"><span data-stu-id="d7b80-361">3.1.2 Performance issues when the object cache has many entities</span></span>

<span data-ttu-id="d7b80-362">O cache de objetos ajuda a aumentar a capacidade de resposta geral do Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="d7b80-362">The object cache helps to increase the overall responsiveness of Entity Framework.</span></span> <span data-ttu-id="d7b80-363">No entanto, quando o cache de objetos tem uma grande quantidade de entidades carregadas pode afetar determinadas operações, como adicionar, remover, localizar, entrada, SaveChanges e muito mais.</span><span class="sxs-lookup"><span data-stu-id="d7b80-363">However, when the object cache has a very large amount of entities loaded it may affect certain operations such as Add, Remove, Find, Entry, SaveChanges and more.</span></span> <span data-ttu-id="d7b80-364">Em particular, operações que disparam uma chamada para DetectChanges serão afetadas negativamente por caches do objeto muito grande.</span><span class="sxs-lookup"><span data-stu-id="d7b80-364">In particular, operations that trigger a call to DetectChanges will be negatively affected by very large object caches.</span></span> <span data-ttu-id="d7b80-365">DetectChanges sincroniza o grafo de objeto com o Gerenciador de estado do objeto e sua vontade de desempenho determinado diretamente pelo tamanho do grafo do objeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-365">DetectChanges synchronizes the object graph with the object state manager and its performance will determined directly by the size of the object graph.</span></span> <span data-ttu-id="d7b80-366">Para obter mais informações sobre DetectChanges, consulte [Controlando alterações em entidades POCO](https://msdn.microsoft.com/library/dd456848.aspx).</span><span class="sxs-lookup"><span data-stu-id="d7b80-366">For more information about DetectChanges, see [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx).</span></span>

<span data-ttu-id="d7b80-367">Ao usar o Entity Framework 6, os desenvolvedores são capazes de chamar AddRange e RemoveRange diretamente em um DbSet, em vez de iterar em uma coleção e chamar a adicionar uma vez por instância.</span><span class="sxs-lookup"><span data-stu-id="d7b80-367">When using Entity Framework 6, developers are able to call AddRange and RemoveRange directly on a DbSet, instead of iterating on a collection and calling Add once per instance.</span></span> <span data-ttu-id="d7b80-368">A vantagem de usar os métodos range é que o custo de DetectChanges é pago apenas uma vez para todo o conjunto de entidades em vez de uma vez por cada entidade adicionada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-368">The advantage of using the range methods is that the cost of DetectChanges is only paid once for the entire set of entities as opposed to once per each added entity.</span></span>

### <a name="32-query-plan-caching"></a><span data-ttu-id="d7b80-369">3.2 cache de plano de consulta de</span><span class="sxs-lookup"><span data-stu-id="d7b80-369">3.2 Query Plan Caching</span></span>

<span data-ttu-id="d7b80-370">Na primeira vez que uma consulta é executada, ele passa pelo compilador plano interno para traduzir a consulta conceitual para o comando de armazenamento (por exemplo, o T-SQL que é executado quando executado no SQL Server).</span><span class="sxs-lookup"><span data-stu-id="d7b80-370">The first time a query is executed, it goes through the internal plan compiler to translate the conceptual query into the store command (for example, the T-SQL which is executed when run against SQL Server).</span></span><span data-ttu-id="d7b80-371">  Se o cache de plano de consulta estiver habilitado, na próxima vez em que a consulta é executada o repositório de comando é recuperado diretamente do cache de plano de consulta para execução, ignorando o compilador de plano.</span><span class="sxs-lookup"><span data-stu-id="d7b80-371">  If query plan caching is enabled, the next time the query is executed the store command is retrieved directly from the query plan cache for execution, bypassing the plan compiler.</span></span>

<span data-ttu-id="d7b80-372">O cache do plano de consulta é compartilhado entre instâncias de ObjectContext dentro do mesmo AppDomain.</span><span class="sxs-lookup"><span data-stu-id="d7b80-372">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span></span> <span data-ttu-id="d7b80-373">Você não precisa manter uma instância de ObjectContext para se beneficiar do cache do plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-373">You don't need to hold onto an ObjectContext instance to benefit from query plan caching.</span></span>

#### <a name="321-some-notes-about-query-plan-caching"></a><span data-ttu-id="d7b80-374">3.2.1 algumas observações sobre o cache de plano de consulta</span><span class="sxs-lookup"><span data-stu-id="d7b80-374">3.2.1 Some notes about Query Plan Caching</span></span>

-   <span data-ttu-id="d7b80-375">O cache do plano de consulta é compartilhado para todos os tipos de consulta: O Entity SQL, LINQ to Entities e objetos CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="d7b80-375">The query plan cache is shared for all query types: Entity SQL, LINQ to Entities, and CompiledQuery objects.</span></span>
-   <span data-ttu-id="d7b80-376">Por padrão, o cache do plano de consulta está habilitado para consultas de Entity SQL, se executados por meio de um EntityCommand ou um ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="d7b80-376">By default, query plan caching is enabled for Entity SQL queries, whether executed through an EntityCommand or through an ObjectQuery.</span></span> <span data-ttu-id="d7b80-377">Ele também é habilitado por padrão para LINQ para consultas de entidades no Entity Framework no .NET 4.5 e no Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="d7b80-377">It is also enabled by default for LINQ to Entities queries in Entity Framework on .NET 4.5, and in Entity Framework 6</span></span>
    -   <span data-ttu-id="d7b80-378">Cache de plano de consulta pode ser desabilitado definindo a propriedade EnablePlanCaching (em EntityCommand ou ObjectQuery) como false.</span><span class="sxs-lookup"><span data-stu-id="d7b80-378">Query plan caching can be disabled by setting the EnablePlanCaching property (on EntityCommand or ObjectQuery) to false.</span></span> <span data-ttu-id="d7b80-379">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-379">For example:</span></span>
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   <span data-ttu-id="d7b80-380">Para consultas parametrizadas, alterar o valor do parâmetro serão atingidos ainda a consulta em cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-380">For parameterized queries, changing the parameter's value will still hit the cached query.</span></span> <span data-ttu-id="d7b80-381">Mas a alteração de facetas de um parâmetro (por exemplo, tamanho, precisão ou escala) atingirá uma entrada diferente no cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-381">But changing a parameter's facets (for example, size, precision, or scale) will hit a different entry in the cache.</span></span>
-   <span data-ttu-id="d7b80-382">Ao usar o Entity SQL, a cadeia de caracteres de consulta é parte da chave.</span><span class="sxs-lookup"><span data-stu-id="d7b80-382">When using Entity SQL, the query string is part of the key.</span></span> <span data-ttu-id="d7b80-383">Alterar a consulta em todos os resultará em entradas de cache diferentes, mesmo se as consultas são funcionalmente equivalentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-383">Changing the query at all will result in different cache entries, even if the queries are functionally equivalent.</span></span> <span data-ttu-id="d7b80-384">Isso inclui alterações de maiusculas e minúsculas ou espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="d7b80-384">This includes changes to casing or whitespace.</span></span>
-   <span data-ttu-id="d7b80-385">Ao usar o LINQ, a consulta é processada para gerar uma parte da chave.</span><span class="sxs-lookup"><span data-stu-id="d7b80-385">When using LINQ, the query is processed to generate a part of the key.</span></span> <span data-ttu-id="d7b80-386">Alterando a expressão LINQ, portanto, gerará uma chave diferente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-386">Changing the LINQ expression will therefore generate a different key.</span></span>
-   <span data-ttu-id="d7b80-387">Outras limitações técnicas podem ser aplicadas; Consulte Autocompiled consultas para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-387">Other technical limitations may apply; see Autocompiled Queries for more details.</span></span>

#### <a name="322-cache-eviction-algorithm"></a><span data-ttu-id="d7b80-388">3.2.2 algoritmo de remoção do cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-388">3.2.2      Cache eviction algorithm</span></span>

<span data-ttu-id="d7b80-389">Noções básicas sobre como funciona o algoritmo interno irá ajudá-lo a descobrir quando para habilitar ou desabilitar o cache de plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-389">Understanding how the internal algorithm works will help you figure out when to enable or disable query plan caching.</span></span> <span data-ttu-id="d7b80-390">O algoritmo de limpeza é da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="d7b80-390">The cleanup algorithm is as follows:</span></span>

1.  <span data-ttu-id="d7b80-391">Depois que o cache contém um número definido de entradas (800), podemos iniciar um timer que periodicamente (uma vez por minuto) varre o cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-391">Once the cache contains a set number of entries (800), we start a timer that periodically (once-per-minute) sweeps the cache.</span></span>
2.  <span data-ttu-id="d7b80-392">Durante limpezas de cache, as entradas são removidas do cache em um LFRU (menos com frequência – usados recentemente) Base.</span><span class="sxs-lookup"><span data-stu-id="d7b80-392">During cache sweeps, entries are removed from the cache on a LFRU (Least frequently – recently used) basis.</span></span> <span data-ttu-id="d7b80-393">Esse algoritmo leva contagem de ocorrências e a idade em conta ao decidir quais entradas são desconsideradas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-393">This algorithm takes both hit count and age into account when deciding which entries are ejected.</span></span>
3.  <span data-ttu-id="d7b80-394">No final de cada varredura de cache, o cache novamente contém 800 entradas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-394">At the end of each cache sweep, the cache again contains 800 entries.</span></span>

<span data-ttu-id="d7b80-395">Todas as entradas de cache são tratadas igualmente ao determinar quais entradas para remover.</span><span class="sxs-lookup"><span data-stu-id="d7b80-395">All cache entries are treated equally when determining which entries to evict.</span></span> <span data-ttu-id="d7b80-396">Isso significa que o comando de armazenamento para um CompiledQuery tem a mesma chance de remoção que o comando de armazenamento para uma consulta Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="d7b80-396">This means the store command for a CompiledQuery has the same chance of eviction as the store command for an Entity SQL query.</span></span>

<span data-ttu-id="d7b80-397">Observe que o timer de remoção do cache é iniciado quando houver 800 entidades no cache, mas o cache é apenas varridas para 60 segundos depois que esse temporizador é iniciado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-397">Note that the cache eviction timer is kicked in when there are 800 entities in the cache, but the cache is only swept 60 seconds after this timer is started.</span></span> <span data-ttu-id="d7b80-398">Isso significa que para até 60 segundos o cache pode atingir a ser muito grandes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-398">That means that for up to 60 seconds your cache may grow to be quite large.</span></span>

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a><span data-ttu-id="d7b80-399">3.2.3 métricas demonstrando o desempenho do cache de plano de consulta de teste</span><span class="sxs-lookup"><span data-stu-id="d7b80-399">3.2.3       Test Metrics demonstrating query plan caching performance</span></span>

<span data-ttu-id="d7b80-400">Para demonstrar o efeito de plano de consulta em cache no desempenho do seu aplicativo, realizamos um teste no qual executamos um número de consultas do Entity SQL com base no modelo Navision.</span><span class="sxs-lookup"><span data-stu-id="d7b80-400">To demonstrate the effect of query plan caching on your application's performance, we performed a test where we executed a number of Entity SQL queries against the Navision model.</span></span> <span data-ttu-id="d7b80-401">Consulte o Apêndice para obter uma descrição do modelo Navision e os tipos de consultas que foram executadas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-401">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="d7b80-402">Este teste, primeiro iterar na lista de consultas e executar cada um de uma vez para adicioná-los no cache (se o cache é habilitado).</span><span class="sxs-lookup"><span data-stu-id="d7b80-402">In this test, we first iterate through the list of queries and execute each one once to add them to the cache (if caching is enabled).</span></span> <span data-ttu-id="d7b80-403">Esta etapa é untimed.</span><span class="sxs-lookup"><span data-stu-id="d7b80-403">This step is untimed.</span></span> <span data-ttu-id="d7b80-404">Em seguida, podemos suspender o thread principal para mais de 60 segundos permitir que o cache de varredura para assumir o lugar; Por fim, iteramos por meio de tempo a lista um 2º para executar as consultas armazenadas em cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-404">Next, we sleep the main thread for over 60 seconds to allow cache sweeping to take place; finally, we iterate through the list a 2nd time to execute the cached queries.</span></span> <span data-ttu-id="d7b80-405">Além disso, o cache de plano do SQL Server é liberado antes de cada conjunto de consultas é executado para que os horários que obtemos com precisão refletem o benefício dado pelo cache de plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-405">Additionally, the SQL Server plan cache is flushed before each set of queries is executed so that the times we obtain accurately reflect the benefit given by the query plan cache.</span></span>

##### <a name="3231-test-results"></a><span data-ttu-id="d7b80-406">3.2.3.1 resultados de teste</span><span class="sxs-lookup"><span data-stu-id="d7b80-406">3.2.3.1       Test Results</span></span>

| <span data-ttu-id="d7b80-407">Teste</span><span class="sxs-lookup"><span data-stu-id="d7b80-407">Test</span></span>                                                                   | <span data-ttu-id="d7b80-408">EF5 no cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-408">EF5 no cache</span></span> | <span data-ttu-id="d7b80-409">EF5 armazenados em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-409">EF5 cached</span></span> | <span data-ttu-id="d7b80-410">EF6 sem cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-410">EF6 no cache</span></span> | <span data-ttu-id="d7b80-411">EF6 armazenados em cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-411">EF6 cached</span></span> |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| <span data-ttu-id="d7b80-412">Enumerando todas as 18723 consultas</span><span class="sxs-lookup"><span data-stu-id="d7b80-412">Enumerating all 18723 queries</span></span>                                          | <span data-ttu-id="d7b80-413">124</span><span class="sxs-lookup"><span data-stu-id="d7b80-413">124</span></span>          | <span data-ttu-id="d7b80-414">125.4</span><span class="sxs-lookup"><span data-stu-id="d7b80-414">125.4</span></span>      | <span data-ttu-id="d7b80-415">124.3</span><span class="sxs-lookup"><span data-stu-id="d7b80-415">124.3</span></span>        | <span data-ttu-id="d7b80-416">125.3</span><span class="sxs-lookup"><span data-stu-id="d7b80-416">125.3</span></span>      |
| <span data-ttu-id="d7b80-417">Evitando varredura (somente as primeiro 800 consultas, independentemente da complexidade)</span><span class="sxs-lookup"><span data-stu-id="d7b80-417">Avoiding sweep (just the first 800 queries, regardless of complexity)</span></span>  | <span data-ttu-id="d7b80-418">41.7</span><span class="sxs-lookup"><span data-stu-id="d7b80-418">41.7</span></span>         | <span data-ttu-id="d7b80-419">5.5</span><span class="sxs-lookup"><span data-stu-id="d7b80-419">5.5</span></span>        | <span data-ttu-id="d7b80-420">40.5</span><span class="sxs-lookup"><span data-stu-id="d7b80-420">40.5</span></span>         | <span data-ttu-id="d7b80-421">5.4</span><span class="sxs-lookup"><span data-stu-id="d7b80-421">5.4</span></span>        |
| <span data-ttu-id="d7b80-422">Somente as consultas AggregatingSubtotals (178 total - que evita a varredura)</span><span class="sxs-lookup"><span data-stu-id="d7b80-422">Just the AggregatingSubtotals queries (178 total - which avoids sweep)</span></span> | <span data-ttu-id="d7b80-423">39.5</span><span class="sxs-lookup"><span data-stu-id="d7b80-423">39.5</span></span>         | <span data-ttu-id="d7b80-424">4.5</span><span class="sxs-lookup"><span data-stu-id="d7b80-424">4.5</span></span>        | <span data-ttu-id="d7b80-425">38.1</span><span class="sxs-lookup"><span data-stu-id="d7b80-425">38.1</span></span>         | <span data-ttu-id="d7b80-426">4.6</span><span class="sxs-lookup"><span data-stu-id="d7b80-426">4.6</span></span>        |

<span data-ttu-id="d7b80-427">*Todo o tempo em segundos.*</span><span class="sxs-lookup"><span data-stu-id="d7b80-427">*All times in seconds.*</span></span>

<span data-ttu-id="d7b80-428">Moral - quando a execução muito de consultas distintas (por exemplo, criado dinamicamente consultas), armazenamento em cache não ajuda e a liberação resultante do cache pode manter as consultas que pode se beneficiar ao máximo do cache de plano de realmente usá-lo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-428">Moral - when executing lots of distinct queries (for example,  dynamically created queries), caching doesn't help and the resulting flushing of the cache can keep the queries that would benefit the most from plan caching from actually using it.</span></span>

<span data-ttu-id="d7b80-429">As consultas de AggregatingSubtotals são as consultas que testamos com mais complexos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-429">The AggregatingSubtotals queries are the most complex of the queries we tested with.</span></span> <span data-ttu-id="d7b80-430">Conforme o esperado, quanto mais complexa a consulta é, mais benefícios terá do cache do plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-430">As expected, the more complex the query is, the more benefit you will see from query plan caching.</span></span>

<span data-ttu-id="d7b80-431">Como um CompiledQuery realmente é uma consulta LINQ com seu plano armazenado em cache, a comparação de um CompiledQuery versus a consulta Entity SQL equivalente deve ter resultados semelhantes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-431">Because a CompiledQuery is really a LINQ query with its plan cached, the comparison of a CompiledQuery versus the equivalent Entity SQL query should have similar results.</span></span> <span data-ttu-id="d7b80-432">Na verdade, se um aplicativo tiver muitas consultas de Entity SQL dinâmicas, preenchimento do cache com consultas também efetivamente causará CompiledQueries a "descompilação" quando eles são liberados do cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-432">In fact, if an app has lots of dynamic Entity SQL queries, filling the cache with queries will also effectively cause CompiledQueries to “decompile” when they are flushed from the cache.</span></span> <span data-ttu-id="d7b80-433">Nesse cenário, o desempenho pode ser melhorado ao desabilitar o cache nas consultas dinâmicas para priorizar o CompiledQueries.</span><span class="sxs-lookup"><span data-stu-id="d7b80-433">In this scenario, performance may be improved by disabling caching on the dynamic queries to prioritize the CompiledQueries.</span></span> <span data-ttu-id="d7b80-434">Melhor ainda, é claro, seria reescrever o aplicativo para usar consultas parametrizadas, em vez de consultas dinâmicas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-434">Better yet, of course, would be to rewrite the app to use parameterized queries instead of dynamic queries.</span></span>

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a><span data-ttu-id="d7b80-435">3.3 usando CompiledQuery para melhorar o desempenho com consultas LINQ</span><span class="sxs-lookup"><span data-stu-id="d7b80-435">3.3 Using CompiledQuery to improve performance with LINQ queries</span></span>

<span data-ttu-id="d7b80-436">Nossos testes indicarem que usar CompiledQuery pode trazer uma vantagem de 7% autocompiled consultas LINQ; Isso significa que você gastará 7% menos tempo de execução de código da pilha do Entity Framework; Isso não significa que seu aplicativo será 7% mais rápida.</span><span class="sxs-lookup"><span data-stu-id="d7b80-436">Our tests indicate that using CompiledQuery can bring a benefit of 7% over autocompiled LINQ queries; this means that you’ll spend 7% less time executing code from the Entity Framework stack; it does not mean your application will be 7% faster.</span></span> <span data-ttu-id="d7b80-437">Em termos gerais, o custo de escrever e manter objetos CompiledQuery no EF 5.0 pode não ser que vale a pena o trabalho em comparação com os benefícios.</span><span class="sxs-lookup"><span data-stu-id="d7b80-437">Generally speaking, the cost of writing and maintaining CompiledQuery objects in EF 5.0 may not be worth the trouble when compared to the benefits.</span></span> <span data-ttu-id="d7b80-438">Sua milhagem pode variar, exercício então, essa opção se seu projeto requer o envio por push adicional.</span><span class="sxs-lookup"><span data-stu-id="d7b80-438">Your mileage may vary, so exercise this option if your project requires the extra push.</span></span> <span data-ttu-id="d7b80-439">Observe que CompiledQueries só são compatíveis com modelos derivada de ObjectContext e não é compatível com modelos derivada de DbContext.</span><span class="sxs-lookup"><span data-stu-id="d7b80-439">Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span></span>

<span data-ttu-id="d7b80-440">Para obter mais informações sobre como criar e invocar um CompiledQuery, consulte [consultas compiladas (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span><span class="sxs-lookup"><span data-stu-id="d7b80-440">For more information on creating and invoking a CompiledQuery, see [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span></span>

<span data-ttu-id="d7b80-441">Há duas considerações que você precisa tomar ao usar um CompiledQuery, ou seja, o requisito para usar instâncias estáticas e os problemas que eles têm com capacidade de composição.</span><span class="sxs-lookup"><span data-stu-id="d7b80-441">There are two considerations you have to take when using a CompiledQuery, namely the requirement to use static instances and the problems they have with composability.</span></span> <span data-ttu-id="d7b80-442">Apresentamos a seguir uma explicação detalhada sobre essas duas considerações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-442">Here follows an in-depth explanation of these two considerations.</span></span>

#### <a name="331-use-static-compiledquery-instances"></a><span data-ttu-id="d7b80-443">3.3.1 use instâncias estáticas de CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="d7b80-443">3.3.1       Use static CompiledQuery instances</span></span>

<span data-ttu-id="d7b80-444">Como compilar uma consulta LINQ é um processo demorado, não queremos fazer isso sempre que precisamos para buscar dados do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-444">Since compiling a LINQ query is a time-consuming process, we don’t want to do it every time we need to fetch data from the database.</span></span> <span data-ttu-id="d7b80-445">As instâncias de CompiledQuery permitem que você compile uma vez e executado várias vezes, mas você precisa ter cuidado e adquiridos para usar a mesma instância de CompiledQuery novamente cada vez, em vez de compilá-lo repetidamente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-445">CompiledQuery instances allow you to compile once and run multiple times, but you have to be careful and procure to re-use the same CompiledQuery instance every time instead of compiling it over and over again.</span></span> <span data-ttu-id="d7b80-446">O uso de membros estáticos para armazenar as instâncias de CompiledQuery se torna necessário; Caso contrário, você não verá nenhum benefício.</span><span class="sxs-lookup"><span data-stu-id="d7b80-446">The use of static members to store the CompiledQuery instances becomes necessary; otherwise you won’t see any benefit.</span></span>

<span data-ttu-id="d7b80-447">Por exemplo, suponha que sua página tem o seguinte corpo de método para lidar com exibindo os produtos para a categoria selecionada:</span><span class="sxs-lookup"><span data-stu-id="d7b80-447">For example, suppose your page has the following method body to handle displaying the products for the selected category:</span></span>

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

<span data-ttu-id="d7b80-448">Nesse caso, você criará uma nova instância de CompiledQuery dinamicamente sempre que o método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-448">In this case, you will create a new CompiledQuery instance on the fly every time the method is called.</span></span> <span data-ttu-id="d7b80-449">Em vez de ver os benefícios de desempenho, recuperando o comando de armazenamento de cache do plano de consulta, o CompiledQuery passará pelo compilador plano sempre que uma nova instância é criada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-449">Instead of seeing performance benefits by retrieving the store command from the query plan cache, the CompiledQuery will go through the plan compiler every time a new instance is created.</span></span> <span data-ttu-id="d7b80-450">Na verdade, você irá ser poluir seu cache do plano de consulta com uma nova entrada CompiledQuery sempre que o método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-450">In fact, you will be polluting your query plan cache with a new CompiledQuery entry every time the method is called.</span></span>

<span data-ttu-id="d7b80-451">Em vez disso, você deseja criar uma instância estática da consulta compilada, portanto, você está invocando a mesma consulta compilada sempre que o método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-451">Instead, you want to create a static instance of the compiled query, so you are invoking the same compiled query every time the method is called.</span></span> <span data-ttu-id="d7b80-452">Uma maneira para que isso seja adicionando-se a instância de CompiledQuery como um membro de seu contexto de objeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-452">One way to so this is by adding the CompiledQuery instance as a member of your object context.</span></span><span data-ttu-id="d7b80-453">  Em seguida, você pode tornar as coisas um pouco cartucho de limpeza, acessando o CompiledQuery através de um método auxiliar:</span><span class="sxs-lookup"><span data-stu-id="d7b80-453">  You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span></span>

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

<span data-ttu-id="d7b80-454">Esse método auxiliar seria invocado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="d7b80-454">This helper method would be invoked as follows:</span></span>

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a><span data-ttu-id="d7b80-455">3.3.2 compondo ao longo de um CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="d7b80-455">3.3.2       Composing over a CompiledQuery</span></span>

<span data-ttu-id="d7b80-456">A capacidade de composição ao longo de qualquer consulta LINQ é extremamente útil; Para fazer isso, você simplesmente invoca um método após o IQueryable como *Skip* ou *Count ()*.</span><span class="sxs-lookup"><span data-stu-id="d7b80-456">The ability to compose over any LINQ query is extremely useful; to do this, you simply invoke a method after the IQueryable such as *Skip()* or *Count()*.</span></span> <span data-ttu-id="d7b80-457">No entanto, fazer, então, essencialmente, retorna um novo objeto IQueryable.</span><span class="sxs-lookup"><span data-stu-id="d7b80-457">However, doing so essentially returns a new IQueryable object.</span></span> <span data-ttu-id="d7b80-458">Embora não haja nada tecnicamente de composição ao longo de um CompiledQuery, isso fará com que a geração de um novo objeto IQueryable que exige passar por meio do compilador plano novamente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-458">While there’s nothing to stop you technically from composing over a CompiledQuery, doing so will cause the generation of a new IQueryable object that requires passing through the plan compiler again.</span></span>

<span data-ttu-id="d7b80-459">Alguns componentes usarão IQueryable composto objetos para habilitar a funcionalidade avançada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-459">Some components will make use of composed IQueryable objects to enable advanced functionality.</span></span> <span data-ttu-id="d7b80-460">Por exemplo, o ASP. GridView da rede pode ser associada a dados para um objeto IQueryable por meio da propriedade SelectMethod.</span><span class="sxs-lookup"><span data-stu-id="d7b80-460">For example, ASP.NET’s GridView can be data-bound to an IQueryable object via the SelectMethod property.</span></span> <span data-ttu-id="d7b80-461">O GridView será, em seguida, compor sobre esse objeto IQueryable para permitir a classificação e paginação em relação ao modelo de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-461">The GridView will then compose over this IQueryable object to allow sorting and paging over the data model.</span></span> <span data-ttu-id="d7b80-462">Como você pode ver, usando um CompiledQuery do GridView não seria atingidos a consulta compilada, mas geraria uma nova consulta autocompiled.</span><span class="sxs-lookup"><span data-stu-id="d7b80-462">As you can see, using a CompiledQuery for the GridView would not hit the compiled query but would generate a new autocompiled query.</span></span>

<span data-ttu-id="d7b80-463">Um lugar onde você pode enfrentar isso é ao adicionar filtros progressivos para uma consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-463">One place where you may run into this is when adding progressive filters to a query.</span></span> <span data-ttu-id="d7b80-464">Por exemplo, suponha que você tivesse uma página de clientes com várias listas suspensas de filtros opcionais (por exemplo, país e OrdersCount).</span><span class="sxs-lookup"><span data-stu-id="d7b80-464">For example, suppose you had a Customers page with several drop-down lists for optional filters (for example, Country and OrdersCount).</span></span> <span data-ttu-id="d7b80-465">Você pode compor esses filtros nos resultados IQueryable de um CompiledQuery, mas fazer isso resultará na nova consulta vai por meio do compilador plano sempre que você executá-lo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-465">You can compose these filters over the IQueryable results of a CompiledQuery, but doing so will result in the new query going through the plan compiler every time you execute it.</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="d7b80-466">Para evitar essa recompilação, você pode reescrever o CompiledQuery para levar os possíveis filtros em consideração:</span><span class="sxs-lookup"><span data-stu-id="d7b80-466">To avoid this re-compilation, you can rewrite the CompiledQuery to take the possible filters into account:</span></span>

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

<span data-ttu-id="d7b80-467">Qual seria invocado na interface do usuário, como:</span><span class="sxs-lookup"><span data-stu-id="d7b80-467">Which would be invoked in the UI like:</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="d7b80-468">Uma desvantagem aqui é o comando de repositório gerada sempre terá os filtros que as verificações de null, mas eles devem ser bastante simples para o servidor de banco de dados otimizar o:</span><span class="sxs-lookup"><span data-stu-id="d7b80-468">A tradeoff here is the generated store command will always have the filters with the null checks, but these should be fairly simple for the database server to optimize:</span></span>

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a><span data-ttu-id="d7b80-469">3.4 cache de metadados</span><span class="sxs-lookup"><span data-stu-id="d7b80-469">3.4 Metadata caching</span></span>

<span data-ttu-id="d7b80-470">O Entity Framework também oferece suporte a cache de metadados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-470">The Entity Framework also supports Metadata caching.</span></span> <span data-ttu-id="d7b80-471">Isso essencialmente é armazenar em cache de informações de tipo e informações de mapeamento de tipo para banco de dados em conexões diferentes para o mesmo modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-471">This is essentially caching of type information and type-to-database mapping information across different connections to the same model.</span></span> <span data-ttu-id="d7b80-472">O cache de metadados é exclusivo por AppDomain.</span><span class="sxs-lookup"><span data-stu-id="d7b80-472">The Metadata cache is unique per AppDomain.</span></span>

#### <a name="341-metadata-caching-algorithm"></a><span data-ttu-id="d7b80-473">3.4.1 algoritmo de cache de metadados</span><span class="sxs-lookup"><span data-stu-id="d7b80-473">3.4.1 Metadata Caching algorithm</span></span>

1.  <span data-ttu-id="d7b80-474">Informações de metadados para um modelo são armazenadas em um ItemCollection para cada EntityConnection.</span><span class="sxs-lookup"><span data-stu-id="d7b80-474">Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span></span>
    -   <span data-ttu-id="d7b80-475">Como uma observação adicional, há objetos ItemCollection diferentes para diferentes partes do modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-475">As a side note, there are different ItemCollection objects for different parts of the model.</span></span> <span data-ttu-id="d7b80-476">Por exemplo, StoreItemCollections contém as informações sobre o modelo de banco de dados. ObjectItemCollection contém informações sobre o modelo de dados. EdmItemCollection contém informações sobre o modelo conceitual.</span><span class="sxs-lookup"><span data-stu-id="d7b80-476">For example, StoreItemCollections contains the information about the database model; ObjectItemCollection contains information about the data model; EdmItemCollection contains information about the conceptual model.</span></span>

2.  <span data-ttu-id="d7b80-477">Se duas conexões usam a mesma cadeia de conexão, eles compartilharão a mesma instância ItemCollection.</span><span class="sxs-lookup"><span data-stu-id="d7b80-477">If two connections use the same connection string, they will share the same ItemCollection instance.</span></span>
3.  <span data-ttu-id="d7b80-478">Cadeias de caracteres de conexão funcionalmente equivalentes, mas textualmente diferentes podem resultar em caches de metadados diferentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-478">Functionally equivalent but textually different connection strings may result in different metadata caches.</span></span> <span data-ttu-id="d7b80-479">Podemos criar tokens de cadeias de caracteres de conexão, simplesmente alterando a ordem dos tokens deve resultar em metadados compartilhados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-479">We do tokenize connection strings, so simply changing the order of the tokens should result in shared metadata.</span></span> <span data-ttu-id="d7b80-480">Mas, duas cadeias de caracteres de conexão que parecem funcionalmente o mesmo não podem ser avaliadas como idênticos após a geração de tokens.</span><span class="sxs-lookup"><span data-stu-id="d7b80-480">But two connection strings that seem functionally the same may not be evaluated as identical after tokenization.</span></span>
4.  <span data-ttu-id="d7b80-481">A ItemCollection periodicamente é verificada para uso.</span><span class="sxs-lookup"><span data-stu-id="d7b80-481">The ItemCollection is periodically checked for use.</span></span> <span data-ttu-id="d7b80-482">Se for determinado que um espaço de trabalho não tiver sido acessado recentemente, ele será marcado para a varredura de cache próxima limpeza.</span><span class="sxs-lookup"><span data-stu-id="d7b80-482">If it is determined that a workspace has not been accessed recently, it will be marked for cleanup on the next cache sweep.</span></span>
5.  <span data-ttu-id="d7b80-483">Apenas a criação de uma EntityConnection fará com que um cache de metadados a ser criado (embora as coleções de itens em que ele não serão inicializadas até que a conexão é aberta).</span><span class="sxs-lookup"><span data-stu-id="d7b80-483">Merely creating an EntityConnection will cause a metadata cache to be created (though the item collections in it will not be initialized until the connection is opened).</span></span> <span data-ttu-id="d7b80-484">Este espaço de trabalho permanece na memória até que o algoritmo do cache determina que ele não é "em uso".</span><span class="sxs-lookup"><span data-stu-id="d7b80-484">This workspace will remain in-memory until the caching algorithm determines it is not “in use”.</span></span>

<span data-ttu-id="d7b80-485">A equipe consultiva para clientes escreveu uma postagem de blog que descreve o que contém uma referência a um ItemCollection para evitar "substituição" ao usar modelos grandes: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-485">The Customer Advisory Team has written a blog post that describes holding a reference to an ItemCollection in order to avoid "deprecation" when using large models: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span></span>

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a><span data-ttu-id="d7b80-486">3.4.2 a relação entre o cache de metadados e o cache de plano de consulta</span><span class="sxs-lookup"><span data-stu-id="d7b80-486">3.4.2 The relationship between Metadata Caching and Query Plan Caching</span></span>

<span data-ttu-id="d7b80-487">A instância de cache do plano de consulta reside em ItemCollection do MetadataWorkspace de tipos de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-487">The query plan cache instance lives in the MetadataWorkspace's ItemCollection of store types.</span></span> <span data-ttu-id="d7b80-488">Isso significa que os comandos de armazenamento em cache serão usados para consultas em qualquer contexto instanciada usando um determinado MetadataWorkspace.</span><span class="sxs-lookup"><span data-stu-id="d7b80-488">This means that cached store commands will be used for queries against any context instantiated using a given MetadataWorkspace.</span></span> <span data-ttu-id="d7b80-489">Isso também significa que se você tiver duas cadeias de caracteres de conexões que são um pouco diferentes e não coincidem depois de criar tokens, você terá consulta diferentes instâncias do cache de plano.</span><span class="sxs-lookup"><span data-stu-id="d7b80-489">It also means that if you have two connections strings that are slightly different and don't match after tokenizing, you will have different query plan cache instances.</span></span>

### <a name="35-results-caching"></a><span data-ttu-id="d7b80-490">3.5 resultados de de cache</span><span class="sxs-lookup"><span data-stu-id="d7b80-490">3.5 Results caching</span></span>

<span data-ttu-id="d7b80-491">Com os resultados de cache (também conhecido como "cache de segundo nível"), você pode manter os resultados de consultas em um cache local.</span><span class="sxs-lookup"><span data-stu-id="d7b80-491">With results caching (also known as "second-level caching"), you keep the results of queries in a local cache.</span></span> <span data-ttu-id="d7b80-492">Ao emitir uma consulta, você primeiro ver se os resultados estão disponíveis localmente antes de você consulta em relação ao armazenamento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-492">When issuing a query, you first see if the results are available locally before you query against the store.</span></span> <span data-ttu-id="d7b80-493">Enquanto o cache de resultados não são suportados diretamente pelo Entity Framework, é possível adicionar um cache de segundo nível, usando um provedor de encapsulamento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-493">While results caching isn't directly supported by Entity Framework, it's possible to add a second level cache by using a wrapping provider.</span></span> <span data-ttu-id="d7b80-494">Um provedor de encapsulamento de exemplo com um cache de segundo nível é do Alachisoft [Cache de segundo nível Entity Framework com base em NCache](http://www.alachisoft.com/ncache/entity-framework.html).</span><span class="sxs-lookup"><span data-stu-id="d7b80-494">An example wrapping provider with a second-level cache is Alachisoft's [Entity Framework Second Level Cache based on NCache](http://www.alachisoft.com/ncache/entity-framework.html).</span></span>

<span data-ttu-id="d7b80-495">Essa implementação do cache de segundo nível é uma funcionalidade injetada que usa o local depois que tiver sido avaliada com a expressão LINQ (e funcletized) e o plano de execução de consulta é computado ou recuperado do cache de primeiro nível.</span><span class="sxs-lookup"><span data-stu-id="d7b80-495">This implementation of second-level caching is an injected functionality that takes place after the LINQ expression has been evaluated (and funcletized) and the query execution plan is computed or retrieved from the first-level cache.</span></span> <span data-ttu-id="d7b80-496">O cache de segundo nível, em seguida, armazenará apenas os resultados de banco de dados brutos, portanto, o pipeline de materialização ainda executa posteriormente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-496">The second-level cache will then store only the raw database results, so the materialization pipeline still executes afterwards.</span></span>

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a><span data-ttu-id="d7b80-497">3.5.1 referências adicionais do para armazenamento em cache com o provedor de encapsulamento de resultados</span><span class="sxs-lookup"><span data-stu-id="d7b80-497">3.5.1 Additional references for results caching with the wrapping provider</span></span>

-   <span data-ttu-id="d7b80-498">Julie Lerman escreveu um artigo do MSDN "Segundo nível de cache no Entity Framework e Windows Azure" que inclui como atualizar o provedor de encapsulamento de exemplo para usar o Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span><span class="sxs-lookup"><span data-stu-id="d7b80-498">Julie Lerman has written a "Second-Level Caching in Entity Framework and Windows Azure" MSDN article that includes how to update the sample wrapping provider to use Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span></span>
-   <span data-ttu-id="d7b80-499">Se você estiver trabalhando com o Entity Framework 5, o blog da equipe tem uma postagem que descreve como executar tarefas em execução com o provedor de cache para o Entity Framework 5: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-499">If you are working with Entity Framework 5, the team blog has a post that describes how to get things running with the caching provider for Entity Framework 5: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span></span> <span data-ttu-id="d7b80-500">Ele também inclui um modelo T4 para ajudar a automatizar a adição de cache de 2º nível ao seu projeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-500">It also includes a T4 template to help automate adding the 2nd-level caching to your project.</span></span>

## <a name="4-autocompiled-queries"></a><span data-ttu-id="d7b80-501">Consultas de Autocompiled 4</span><span class="sxs-lookup"><span data-stu-id="d7b80-501">4 Autocompiled Queries</span></span>

<span data-ttu-id="d7b80-502">Quando uma consulta é feita em um banco de dados usando o Entity Framework, precisa passar por uma série de etapas antes de realmente materializar resultados; um essa etapa é a compilação da consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-502">When a query is issued against a database using Entity Framework, it must go through a series of steps before actually materializing the results; one such step is Query Compilation.</span></span> <span data-ttu-id="d7b80-503">Consultas Entity SQL eram conhecidas por ter bom desempenho conforme eles são automaticamente armazenadas em cache, portanto, a segunda ou terceira vez que você executar a mesma consulta pode ignorar o compilador de plano e usar o plano armazenado em cache em vez disso.</span><span class="sxs-lookup"><span data-stu-id="d7b80-503">Entity SQL queries were known to have good performance as they are automatically cached, so the second or third time you execute the same query it can skip the plan compiler and use the cached plan instead.</span></span>

<span data-ttu-id="d7b80-504">O Entity Framework 5 introduziu o armazenamento em cache automático para LINQ para consultas de entidades, bem.</span><span class="sxs-lookup"><span data-stu-id="d7b80-504">Entity Framework 5 introduced automatic caching for LINQ to Entities queries as well.</span></span> <span data-ttu-id="d7b80-505">Em edições anteriores do Entity Framework, criando um CompiledQuery para acelerar o desempenho foi uma prática comum, pois isso tornaria o LINQ para consultar entidades armazenáveis em cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-505">In past editions of Entity Framework creating a CompiledQuery to speed your performance was a common practice, as this would make your LINQ to Entities query cacheable.</span></span> <span data-ttu-id="d7b80-506">Uma vez que o cache agora é feito automaticamente sem o uso de um CompiledQuery, chamamos esse recurso "autocompiled consultas".</span><span class="sxs-lookup"><span data-stu-id="d7b80-506">Since caching is now done automatically without the use of a CompiledQuery, we call this feature “autocompiled queries”.</span></span> <span data-ttu-id="d7b80-507">Para obter mais informações sobre o cache do plano de consulta e sua mecânica, consulte o cachê do plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-507">For more information about the query plan cache and its mechanics, see Query Plan Caching.</span></span>

<span data-ttu-id="d7b80-508">Entity Framework detecta quando uma consulta precisa ser recompilado, e faz isso quando a consulta é invocada, mesmo se ele tivesse sido compilado antes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-508">Entity Framework detects when a query requires to be recompiled, and does so when the query is invoked even if it had been compiled before.</span></span> <span data-ttu-id="d7b80-509">Condições comuns que fazem com que a consulta seja recompilada são:</span><span class="sxs-lookup"><span data-stu-id="d7b80-509">Common conditions that cause the query to be recompiled are:</span></span>

-   <span data-ttu-id="d7b80-510">Alterando o MergeOption associado à sua consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-510">Changing the MergeOption associated to your query.</span></span> <span data-ttu-id="d7b80-511">A consulta em cache não será usada, em vez disso, o compilador de plano será executado novamente e o plano recém-criado é armazenado em cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-511">The cached query will not be used, instead the plan compiler will run again and the newly created plan gets cached.</span></span>
-   <span data-ttu-id="d7b80-512">Alterar o valor de ContextOptions.UseCSharpNullComparisonBehavior.</span><span class="sxs-lookup"><span data-stu-id="d7b80-512">Changing the value of ContextOptions.UseCSharpNullComparisonBehavior.</span></span> <span data-ttu-id="d7b80-513">Você obtém o mesmo efeito de alterar o MergeOption.</span><span class="sxs-lookup"><span data-stu-id="d7b80-513">You get the same effect as changing the MergeOption.</span></span>

<span data-ttu-id="d7b80-514">Outras condições podem impedir que a consulta usando o cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-514">Other conditions can prevent your query from using the cache.</span></span> <span data-ttu-id="d7b80-515">Exemplos comuns são:</span><span class="sxs-lookup"><span data-stu-id="d7b80-515">Common examples are:</span></span>

-   <span data-ttu-id="d7b80-516">Usando o IEnumerable&lt;T&gt;. Contém&lt;&gt;(valor de T).</span><span class="sxs-lookup"><span data-stu-id="d7b80-516">Using IEnumerable&lt;T&gt;.Contains&lt;&gt;(T value).</span></span>
-   <span data-ttu-id="d7b80-517">Usando funções que geram consultas com constantes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-517">Using functions that produce queries with constants.</span></span>
-   <span data-ttu-id="d7b80-518">Usando as propriedades de um objeto não mapeados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-518">Using the properties of a non-mapped object.</span></span>
-   <span data-ttu-id="d7b80-519">Vinculando a consulta a outra consulta que requer ser recompilado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-519">Linking your query to another query that requires to be recompiled.</span></span>

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a><span data-ttu-id="d7b80-520">4.1 usando IEnumerable&lt;T&gt;. Contém&lt;T&gt;(valor de T)</span><span class="sxs-lookup"><span data-stu-id="d7b80-520">4.1 Using IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value)</span></span>

<span data-ttu-id="d7b80-521">Entity Framework não armazena em cache consultas que invocam IEnumerable&lt;T&gt;. Contém&lt;T&gt;(valor de T) em relação a uma coleção em memória, como os valores da coleção são considerados voláteis.</span><span class="sxs-lookup"><span data-stu-id="d7b80-521">Entity Framework does not cache queries that invoke IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) against an in-memory collection, since the values of the collection are considered volatile.</span></span> <span data-ttu-id="d7b80-522">A consulta de exemplo a seguir não será armazenada, portanto, ele sempre será processado pelo compilador plano:</span><span class="sxs-lookup"><span data-stu-id="d7b80-522">The following example query will not be cached, so it will always be processed by the plan compiler:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="d7b80-523">Observe que o tamanho de IEnumerable em relação a quais Contains é executado determina o quão rápido ou lento como sua consulta é compilada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-523">Note that the size of the IEnumerable against which Contains is executed determines how fast or how slow your query is compiled.</span></span> <span data-ttu-id="d7b80-524">Desempenho poderá ser afetado de forma significativa ao uso de coleções grandes, como mostrado no exemplo acima.</span><span class="sxs-lookup"><span data-stu-id="d7b80-524">Performance can suffer significantly when using large collections such as the one shown in the example above.</span></span>

<span data-ttu-id="d7b80-525">Entity Framework 6 contém otimizações na forma IEnumerable&lt;T&gt;. Contém&lt;T&gt;(valor de T) funciona quando as consultas são executadas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-525">Entity Framework 6 contains optimizations to the way IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) works when queries are executed.</span></span> <span data-ttu-id="d7b80-526">O código SQL gerado é muito mais rápido para produzir e mais legível e, na maioria dos casos ele também executa com mais rapidez no servidor.</span><span class="sxs-lookup"><span data-stu-id="d7b80-526">The SQL code that is generated is much faster to produce and more readable, and in most cases it also executes faster in the server.</span></span>

### <a name="42-using-functions-that-produce-queries-with-constants"></a><span data-ttu-id="d7b80-527">4.2 usando funções que geram consultas com constantes</span><span class="sxs-lookup"><span data-stu-id="d7b80-527">4.2 Using functions that produce queries with constants</span></span>

<span data-ttu-id="d7b80-528">Os operadores Skip, Take (,) Contains () e LINQ DefautIfEmpty() gera consultas SQL com parâmetros, mas em vez disso, coloque os valores passados a eles como constantes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-528">The Skip(), Take(), Contains() and DefautIfEmpty() LINQ operators do not produce SQL queries with parameters but instead put the values passed to them as constants.</span></span> <span data-ttu-id="d7b80-529">Por isso, consultas que poderiam ser idêntica acaba poluir a consulta planejar o cache, na pilha de EF e o servidor de banco de dados e não obter reutilizadas, a menos que o mesmas constantes são usadas em uma execução de consulta subsequentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-529">Because of this, queries that might otherwise be identical end up polluting the query plan cache, both on the EF stack and on the database server, and do not get reutilized unless the same constants are used in a subsequent query execution.</span></span> <span data-ttu-id="d7b80-530">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-530">For example:</span></span>

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="d7b80-531">Neste exemplo, cada vez que essa consulta é executada com um valor diferente para a id da consulta será compilado em um novo plano.</span><span class="sxs-lookup"><span data-stu-id="d7b80-531">In this example, each time this query is executed with a different value for id the query will be compiled into a new plan.</span></span>

<span data-ttu-id="d7b80-532">Em particular preste atenção o uso de Skip e Take ao fazer a paginação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-532">In particular pay attention to the use of Skip and Take when doing paging.</span></span> <span data-ttu-id="d7b80-533">No EF6, esses métodos têm uma sobrecarga de lambda que torna efetivamente o plano de consulta em cache reutilizáveis porque o EF pode capturar variáveis passadas para esses métodos e convertê-las em SQLparameters.</span><span class="sxs-lookup"><span data-stu-id="d7b80-533">In EF6 these methods have a lambda overload that effectively makes the cached query plan reusable because EF can capture variables passed to these methods and translate them to SQLparameters.</span></span> <span data-ttu-id="d7b80-534">Isso também ajuda a manter o cache de limpeza, pois, caso contrário, cada consulta com uma constante diferente de Skip e Take teria sua própria entrada de cache do plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-534">This also helps keep the cache cleaner since otherwise each query with a different constant for Skip and Take would get its own query plan cache entry.</span></span>

<span data-ttu-id="d7b80-535">Considere o código a seguir, que está abaixo do ideal, mas serve para exemplificar essa classe de consultas:</span><span class="sxs-lookup"><span data-stu-id="d7b80-535">Consider the following code, which is suboptimal but is only meant to exemplify this class of queries:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="d7b80-536">Uma versão mais rápida desse mesmo código envolveria chamando Skip com um lambda:</span><span class="sxs-lookup"><span data-stu-id="d7b80-536">A faster version of this same code would involve calling Skip with a lambda:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="d7b80-537">O segundo trecho pode executar até 11% mais rápido porque o mesmo plano de consulta é usado sempre que a consulta é executada, o que economiza tempo de CPU e evita poluam o cache de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-537">The second snippet may run up to 11% faster because the same query plan is used every time the query is run, which saves CPU time and avoids polluting the query cache.</span></span> <span data-ttu-id="d7b80-538">Além disso, porque o parâmetro para ignorar está em um fechamento o código também essa aparência agora:</span><span class="sxs-lookup"><span data-stu-id="d7b80-538">Furthermore, because the parameter to Skip is in a closure the code might as well look like this now:</span></span>

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a><span data-ttu-id="d7b80-539">4.3 usando as propriedades de um objeto não mapeados</span><span class="sxs-lookup"><span data-stu-id="d7b80-539">4.3 Using the properties of a non-mapped object</span></span>

<span data-ttu-id="d7b80-540">Quando uma consulta usa as propriedades de um tipo de objeto não mapeados como um parâmetro, a consulta será não ficar armazenada em cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-540">When a query uses the properties of a non-mapped object type as a parameter then the query will not get cached.</span></span> <span data-ttu-id="d7b80-541">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-541">For example:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

<span data-ttu-id="d7b80-542">Neste exemplo, suponha que a classe NonMappedType não é parte do modelo de entidade.</span><span class="sxs-lookup"><span data-stu-id="d7b80-542">In this example, assume that class NonMappedType is not part of the Entity model.</span></span> <span data-ttu-id="d7b80-543">Essa consulta pode ser alterada facilmente para não usar um tipo não mapeados e em vez disso, use uma variável local como o parâmetro para a consulta:</span><span class="sxs-lookup"><span data-stu-id="d7b80-543">This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="d7b80-544">Nesse caso, a consulta poderá ficar armazenada em cache e se beneficiará do cache do plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-544">In this case, the query will be able to get cached and will benefit from the query plan cache.</span></span>

### <a name="44-linking-to-queries-that-require-recompiling"></a><span data-ttu-id="d7b80-545">4.4 vinculando a consultas que requerem a recompilação</span><span class="sxs-lookup"><span data-stu-id="d7b80-545">4.4 Linking to queries that require recompiling</span></span>

<span data-ttu-id="d7b80-546">Seguindo o mesmo exemplo acima, se você tiver uma segunda consulta que se baseia em uma consulta que precisa ser recompilado, toda segunda consulta também será recompilada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-546">Following the same example as above, if you have a second query that relies on a query that needs to be recompiled, your entire second query will also be recompiled.</span></span> <span data-ttu-id="d7b80-547">Aqui está um exemplo para ilustrar esse cenário:</span><span class="sxs-lookup"><span data-stu-id="d7b80-547">Here’s an example to illustrate this scenario:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

<span data-ttu-id="d7b80-548">O exemplo é genérico, mas ilustra como a vinculação a firstQuery está causando secondQuery não possa ficar armazenada em cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-548">The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span></span> <span data-ttu-id="d7b80-549">Se firstQuery não tivesse sido uma consulta que requer a recompilação, em seguida, secondQuery seria tiverem sido armazenados em cache.</span><span class="sxs-lookup"><span data-stu-id="d7b80-549">If firstQuery had not been a query that requires recompiling, then secondQuery would have been cached.</span></span>

## <a name="5-notracking-queries"></a><span data-ttu-id="d7b80-550">5 consultas NoTracking</span><span class="sxs-lookup"><span data-stu-id="d7b80-550">5 NoTracking Queries</span></span>

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a><span data-ttu-id="d7b80-551">5.1 desabilitando o controle de alterações para reduzir a sobrecarga de gerenciamento de estado</span><span class="sxs-lookup"><span data-stu-id="d7b80-551">5.1 Disabling change tracking to reduce state management overhead</span></span>

<span data-ttu-id="d7b80-552">Se você estiver em um cenário de somente leitura e deseja evitar a sobrecarga de carregar os objetos no ObjectStateManager, você pode emitir consultas de "Sem o controle".</span><span class="sxs-lookup"><span data-stu-id="d7b80-552">If you are in a read-only scenario and want to avoid the overhead of loading the objects into the ObjectStateManager, you can issue "No Tracking" queries.</span></span><span data-ttu-id="d7b80-553">  Controle de alterações podem ser desabilitada no nível da consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-553">  Change tracking can be disabled at the query level.</span></span>

<span data-ttu-id="d7b80-554">No entanto, observe que ao desabilitar a você o controle de alterações são efetivamente desativar o cache de objetos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-554">Note though that by disabling change tracking you are effectively turning off the object cache.</span></span> <span data-ttu-id="d7b80-555">Quando você consulta para uma entidade, podemos não é possível ignorar materialização puxando os resultados da consulta materializado anteriormente do ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="d7b80-555">When you query for an entity, we can't skip materialization by pulling the previously-materialized query results from the ObjectStateManager.</span></span> <span data-ttu-id="d7b80-556">Se você estiver consultando repetidamente as mesmas entidades no mesmo contexto, você pode realmente ver um desempenho se beneficiar da habilitação do controle de alterações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-556">If you are repeatedly querying for the same entities on the same context, you might actually see a performance benefit from enabling change tracking.</span></span>

<span data-ttu-id="d7b80-557">Ao consultar o uso de ObjectContext, instâncias ObjectQuery e ObjectSet irão se lembrar um MergeOption depois que ele é definido e consultas que são compostos por neles herdará o MergeOption efetivação da consulta pai.</span><span class="sxs-lookup"><span data-stu-id="d7b80-557">When querying using ObjectContext, ObjectQuery and ObjectSet instances will remember a MergeOption once it is set, and queries that are composed on them will inherit the effective MergeOption of the parent query.</span></span> <span data-ttu-id="d7b80-558">Ao usar o DbContext, o rastreamento pode ser desabilitado chamando o modificador AsNoTracking() no DbSet.</span><span class="sxs-lookup"><span data-stu-id="d7b80-558">When using DbContext, tracking can be disabled by calling the AsNoTracking() modifier on the DbSet.</span></span>

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a><span data-ttu-id="d7b80-559">5.1.1 desabilitando o controle de alterações para uma consulta ao usar o DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-559">5.1.1 Disabling change tracking for a query when using DbContext</span></span>

<span data-ttu-id="d7b80-560">Você pode alternar o modo de uma consulta para NoTracking por meio do encadeamento uma chamada ao método AsNoTracking() na consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-560">You can switch the mode of a query to NoTracking by chaining a call to the AsNoTracking() method in the query.</span></span> <span data-ttu-id="d7b80-561">Ao contrário de ObjectQuery, as classes de DbSet e DbQuery na API do DbContext não tem uma propriedade mutável para o MergeOption.</span><span class="sxs-lookup"><span data-stu-id="d7b80-561">Unlike ObjectQuery, the DbSet and DbQuery classes in the DbContext API don’t have a mutable property for the MergeOption.</span></span>

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a><span data-ttu-id="d7b80-562">5.1.2 desabilitando o controle de alterações no nível da consulta usando ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-562">5.1.2 Disabling change tracking at the query level using ObjectContext</span></span>

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a><span data-ttu-id="d7b80-563">5.1.3 desabilitando o controle de alterações para uma entidade inteira definida usando ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-563">5.1.3 Disabling change tracking for an entire entity set using ObjectContext</span></span>

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a><span data-ttu-id="d7b80-564">5.2 métricas de teste demonstrando o benefício de desempenho de consultas NoTracking</span><span class="sxs-lookup"><span data-stu-id="d7b80-564">5.2 Test Metrics demonstrating the performance benefit of NoTracking queries</span></span>

<span data-ttu-id="d7b80-565">Nesse teste, vamos às custas de preencher o ObjectStateManager comparando o acompanhamento para consultas NoTracking para o modelo Navision.</span><span class="sxs-lookup"><span data-stu-id="d7b80-565">In this test we look at the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span></span> <span data-ttu-id="d7b80-566">Consulte o Apêndice para obter uma descrição do modelo Navision e os tipos de consultas que foram executadas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-566">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="d7b80-567">Nesse teste, podemos percorrer a lista de consultas e executar uma vez, cada um deles.</span><span class="sxs-lookup"><span data-stu-id="d7b80-567">In this test, we iterate through the list of queries and execute each one once.</span></span> <span data-ttu-id="d7b80-568">Executamos duas variações do teste, uma vez com consultas NoTracking e uma vez com a opção de mesclagem padrão de "AppendOnly".</span><span class="sxs-lookup"><span data-stu-id="d7b80-568">We ran two variations of the test, once with NoTracking queries and once with the default merge option of "AppendOnly".</span></span> <span data-ttu-id="d7b80-569">Executamos cada variação de 3 vezes e levar o valor médio das execuções.</span><span class="sxs-lookup"><span data-stu-id="d7b80-569">We ran each variation 3 times and take the mean value of the runs.</span></span> <span data-ttu-id="d7b80-570">Entre os testes, limpar o cache de consulta no SQL Server e reduzir o tempdb, executando os comandos a seguir:</span><span class="sxs-lookup"><span data-stu-id="d7b80-570">Between the tests we clear the query cache on the SQL Server and shrink the tempdb by running the following commands:</span></span>

1.  <span data-ttu-id="d7b80-571">DBCC DROPCLEANBUFFERS</span><span class="sxs-lookup"><span data-stu-id="d7b80-571">DBCC DROPCLEANBUFFERS</span></span>
2.  <span data-ttu-id="d7b80-572">DBCC FREEPROCCACHE</span><span class="sxs-lookup"><span data-stu-id="d7b80-572">DBCC FREEPROCCACHE</span></span>
3.  <span data-ttu-id="d7b80-573">DBCC SHRINKDATABASE (tempdb, 0)</span><span class="sxs-lookup"><span data-stu-id="d7b80-573">DBCC SHRINKDATABASE (tempdb, 0)</span></span>

<span data-ttu-id="d7b80-574">Teste os resultados, mediano executa mais de 3:</span><span class="sxs-lookup"><span data-stu-id="d7b80-574">Test Results, median over 3 runs:</span></span>

|                        | <span data-ttu-id="d7b80-575">NENHUM CONTROLE – CONJUNTO DE TRABALHO</span><span class="sxs-lookup"><span data-stu-id="d7b80-575">NO TRACKING – WORKING SET</span></span> | <span data-ttu-id="d7b80-576">NENHUM RASTREAMENTO – HORA</span><span class="sxs-lookup"><span data-stu-id="d7b80-576">NO TRACKING – TIME</span></span> | <span data-ttu-id="d7b80-577">ACRESCENTAR APENAS – CONJUNTO DE TRABALHO</span><span class="sxs-lookup"><span data-stu-id="d7b80-577">APPEND ONLY – WORKING SET</span></span> | <span data-ttu-id="d7b80-578">TEMPO – SOMENTE DE ACRÉSCIMO</span><span class="sxs-lookup"><span data-stu-id="d7b80-578">APPEND ONLY – TIME</span></span> |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| <span data-ttu-id="d7b80-579">**O Entity Framework 5**</span><span class="sxs-lookup"><span data-stu-id="d7b80-579">**Entity Framework 5**</span></span> | <span data-ttu-id="d7b80-580">460361728</span><span class="sxs-lookup"><span data-stu-id="d7b80-580">460361728</span></span>                 | <span data-ttu-id="d7b80-581">1163536 ms</span><span class="sxs-lookup"><span data-stu-id="d7b80-581">1163536 ms</span></span>         | <span data-ttu-id="d7b80-582">596545536</span><span class="sxs-lookup"><span data-stu-id="d7b80-582">596545536</span></span>                 | <span data-ttu-id="d7b80-583">1273042 ms</span><span class="sxs-lookup"><span data-stu-id="d7b80-583">1273042 ms</span></span>         |
| <span data-ttu-id="d7b80-584">**Entity Framework 6**</span><span class="sxs-lookup"><span data-stu-id="d7b80-584">**Entity Framework 6**</span></span> | <span data-ttu-id="d7b80-585">647127040</span><span class="sxs-lookup"><span data-stu-id="d7b80-585">647127040</span></span>                 | <span data-ttu-id="d7b80-586">190228 ms</span><span class="sxs-lookup"><span data-stu-id="d7b80-586">190228 ms</span></span>          | <span data-ttu-id="d7b80-587">832798720</span><span class="sxs-lookup"><span data-stu-id="d7b80-587">832798720</span></span>                 | <span data-ttu-id="d7b80-588">195521 ms</span><span class="sxs-lookup"><span data-stu-id="d7b80-588">195521 ms</span></span>          |

<span data-ttu-id="d7b80-589">O Entity Framework 5 terão um volume de memória menor no final da execução que o Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="d7b80-589">Entity Framework 5 will have a smaller memory footprint at the end of the run than Entity Framework 6 does.</span></span> <span data-ttu-id="d7b80-590">A memória adicional consumida pelo Entity Framework 6 é o resultado de estruturas de memória adicional e o código que habilitam novos recursos e melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="d7b80-590">The additional memory consumed by Entity Framework 6 is the result of additional memory structures and code that enable new features and better performance.</span></span>

<span data-ttu-id="d7b80-591">Também há uma diferença clara na superfície de memória ao usar o ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="d7b80-591">There’s also a clear difference in memory footprint when using the ObjectStateManager.</span></span> <span data-ttu-id="d7b80-592">O Entity Framework 5 aumentou seu impacto em 30% ao manter o controle de todas as entidades que podemos materializados do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-592">Entity Framework 5 increased its footprint by 30% when keeping track of all the entities we materialized from the database.</span></span> <span data-ttu-id="d7b80-593">Entity Framework 6 aumenta sua pegada, 28% ao fazer isso.</span><span class="sxs-lookup"><span data-stu-id="d7b80-593">Entity Framework 6 increased its footprint by 28% when doing so.</span></span>

<span data-ttu-id="d7b80-594">Em termos de tempo, o Entity Framework 6 supera o Entity Framework 5 neste teste por uma grande margem.</span><span class="sxs-lookup"><span data-stu-id="d7b80-594">In terms of time, Entity Framework 6 outperforms Entity Framework 5 in this test by a large margin.</span></span> <span data-ttu-id="d7b80-595">Entity Framework 6 concluiu o teste em aproximadamente 16% do tempo consumido pelo Entity Framework 5.</span><span class="sxs-lookup"><span data-stu-id="d7b80-595">Entity Framework 6 completed the test in roughly 16% of the time consumed by Entity Framework 5.</span></span> <span data-ttu-id="d7b80-596">Além disso, o Entity Framework 5 leva 9% mais tempo para ser concluído quando o ObjectStateManager está sendo usado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-596">Additionally, Entity Framework 5 takes 9% more time to complete when the ObjectStateManager is being used.</span></span> <span data-ttu-id="d7b80-597">Em comparação, o Entity Framework 6 está usando mais tempo ao usar o ObjectStateManager de % 3.</span><span class="sxs-lookup"><span data-stu-id="d7b80-597">In comparison, Entity Framework 6 is using 3% more time when using the ObjectStateManager.</span></span>

## <a name="6-query-execution-options"></a><span data-ttu-id="d7b80-598">Opções de execução de consulta 6</span><span class="sxs-lookup"><span data-stu-id="d7b80-598">6 Query Execution Options</span></span>

<span data-ttu-id="d7b80-599">Entity Framework oferece várias maneiras diferentes de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-599">Entity Framework offers several different ways to query.</span></span> <span data-ttu-id="d7b80-600">Vamos examinar as opções a seguir, comparar os prós e contras de cada e examinar suas características de desempenho:</span><span class="sxs-lookup"><span data-stu-id="d7b80-600">We'll take a look at the following options, compare the pros and cons of each, and examine their performance characteristics:</span></span>

-   <span data-ttu-id="d7b80-601">LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="d7b80-601">LINQ to Entities.</span></span>
-   <span data-ttu-id="d7b80-602">Nenhum rastreamento LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="d7b80-602">No Tracking LINQ to Entities.</span></span>
-   <span data-ttu-id="d7b80-603">Entity SQL em um ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="d7b80-603">Entity SQL over an ObjectQuery.</span></span>
-   <span data-ttu-id="d7b80-604">Entity SQL ao longo de um EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="d7b80-604">Entity SQL over an EntityCommand.</span></span>
-   <span data-ttu-id="d7b80-605">ExecuteStoreQuery.</span><span class="sxs-lookup"><span data-stu-id="d7b80-605">ExecuteStoreQuery.</span></span>
-   <span data-ttu-id="d7b80-606">SqlQuery.</span><span class="sxs-lookup"><span data-stu-id="d7b80-606">SqlQuery.</span></span>
-   <span data-ttu-id="d7b80-607">CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="d7b80-607">CompiledQuery.</span></span>

### <a name="61-linq-to-entities-queries"></a><span data-ttu-id="d7b80-608">6.1 consultas LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="d7b80-608">6.1       LINQ to Entities queries</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="d7b80-609">**Profissionais**</span><span class="sxs-lookup"><span data-stu-id="d7b80-609">**Pros**</span></span>

-   <span data-ttu-id="d7b80-610">Adequado para operações CUD.</span><span class="sxs-lookup"><span data-stu-id="d7b80-610">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="d7b80-611">Objetos totalmente materializados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-611">Fully materialized objects.</span></span>
-   <span data-ttu-id="d7b80-612">Mais simples de escrever com sintaxe integrada à linguagem de programação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-612">Simplest to write with syntax built into the programming language.</span></span>
-   <span data-ttu-id="d7b80-613">Bom desempenho.</span><span class="sxs-lookup"><span data-stu-id="d7b80-613">Good performance.</span></span>

<span data-ttu-id="d7b80-614">**Contras**</span><span class="sxs-lookup"><span data-stu-id="d7b80-614">**Cons**</span></span>

-   <span data-ttu-id="d7b80-615">Determinadas restrições técnicas, tais como:</span><span class="sxs-lookup"><span data-stu-id="d7b80-615">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="d7b80-616">Padrões para consultas de junção externa. usando DefaultIfEmpty resultam em consultas mais complexas que instruções simples OUTER JOIN em Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="d7b80-616">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="d7b80-617">Você ainda não é possível usar LIKE com a correspondência de padrões gerais.</span><span class="sxs-lookup"><span data-stu-id="d7b80-617">You still can’t use LIKE with general pattern matching.</span></span>

### <a name="62-no-tracking-linq-to-entities-queries"></a><span data-ttu-id="d7b80-618">6.2 nenhum acompanhamento LINQ para consultas de entidades</span><span class="sxs-lookup"><span data-stu-id="d7b80-618">6.2       No Tracking LINQ to Entities queries</span></span>

<span data-ttu-id="d7b80-619">Quando o contexto deriva ObjectContext:</span><span class="sxs-lookup"><span data-stu-id="d7b80-619">When the context derives ObjectContext:</span></span>

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="d7b80-620">Quando o contexto deriva de DbContext:</span><span class="sxs-lookup"><span data-stu-id="d7b80-620">When the context derives DbContext:</span></span>

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="d7b80-621">**Profissionais**</span><span class="sxs-lookup"><span data-stu-id="d7b80-621">**Pros**</span></span>

-   <span data-ttu-id="d7b80-622">Desempenho aprimorado em consultas LINQ regulares.</span><span class="sxs-lookup"><span data-stu-id="d7b80-622">Improved performance over regular LINQ queries.</span></span>
-   <span data-ttu-id="d7b80-623">Objetos totalmente materializados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-623">Fully materialized objects.</span></span>
-   <span data-ttu-id="d7b80-624">Mais simples de escrever com sintaxe integrada à linguagem de programação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-624">Simplest to write with syntax built into the programming language.</span></span>

<span data-ttu-id="d7b80-625">**Contras**</span><span class="sxs-lookup"><span data-stu-id="d7b80-625">**Cons**</span></span>

-   <span data-ttu-id="d7b80-626">Não é adequado para operações CUD.</span><span class="sxs-lookup"><span data-stu-id="d7b80-626">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="d7b80-627">Determinadas restrições técnicas, tais como:</span><span class="sxs-lookup"><span data-stu-id="d7b80-627">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="d7b80-628">Padrões para consultas de junção externa. usando DefaultIfEmpty resultam em consultas mais complexas que instruções simples OUTER JOIN em Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="d7b80-628">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="d7b80-629">Você ainda não é possível usar LIKE com a correspondência de padrões gerais.</span><span class="sxs-lookup"><span data-stu-id="d7b80-629">You still can’t use LIKE with general pattern matching.</span></span>

<span data-ttu-id="d7b80-630">Observe que consultas que propriedades escalares do projeto não são controladas, mesmo se o NoTracking não for especificado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-630">Note that queries that project scalar properties are not tracked even if the NoTracking is not specified.</span></span> <span data-ttu-id="d7b80-631">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-631">For example:</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

<span data-ttu-id="d7b80-632">Essa consulta específica não especifica explicitamente que está sendo NoTracking, mas uma vez que não a materialização um tipo que se sabe que o Gerenciador de estado do objeto, em seguida, o resultado materializado não é controlado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-632">This particular query doesn’t explicitly specify being NoTracking, but since it’s not materializing a type that’s known to the object state manager then the materialized result is not tracked.</span></span>

### <a name="63-entity-sql-over-an-objectquery"></a><span data-ttu-id="d7b80-633">6.3 entity SQL sobre um ObjectQuery</span><span class="sxs-lookup"><span data-stu-id="d7b80-633">6.3       Entity SQL over an ObjectQuery</span></span>

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

<span data-ttu-id="d7b80-634">**Profissionais**</span><span class="sxs-lookup"><span data-stu-id="d7b80-634">**Pros**</span></span>

-   <span data-ttu-id="d7b80-635">Adequado para operações CUD.</span><span class="sxs-lookup"><span data-stu-id="d7b80-635">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="d7b80-636">Objetos totalmente materializados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-636">Fully materialized objects.</span></span>
-   <span data-ttu-id="d7b80-637">Dá suporte a cache de plano de consulta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-637">Supports query plan caching.</span></span>

<span data-ttu-id="d7b80-638">**Contras**</span><span class="sxs-lookup"><span data-stu-id="d7b80-638">**Cons**</span></span>

-   <span data-ttu-id="d7b80-639">Envolve cadeias de caracteres de consulta textual que são mais propensas a erro de usuário que construções de consulta integradas à linguagem.</span><span class="sxs-lookup"><span data-stu-id="d7b80-639">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>

### <a name="64-entity-sql-over-an-entity-command"></a><span data-ttu-id="d7b80-640">6.4 entity SQL sobre um comando de entidade</span><span class="sxs-lookup"><span data-stu-id="d7b80-640">6.4       Entity SQL over an Entity Command</span></span>

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

<span data-ttu-id="d7b80-641">**Profissionais**</span><span class="sxs-lookup"><span data-stu-id="d7b80-641">**Pros**</span></span>

-   <span data-ttu-id="d7b80-642">Dá suporte à consulta o cache de plano no .NET 4.0 (cache de plano é suportado por todos os outros tipos de consulta no .NET 4.5).</span><span class="sxs-lookup"><span data-stu-id="d7b80-642">Supports query plan caching in .NET 4.0 (plan caching is supported by all other query types in .NET 4.5).</span></span>

<span data-ttu-id="d7b80-643">**Contras**</span><span class="sxs-lookup"><span data-stu-id="d7b80-643">**Cons**</span></span>

-   <span data-ttu-id="d7b80-644">Envolve cadeias de caracteres de consulta textual que são mais propensas a erro de usuário que construções de consulta integradas à linguagem.</span><span class="sxs-lookup"><span data-stu-id="d7b80-644">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>
-   <span data-ttu-id="d7b80-645">Não é adequado para operações CUD.</span><span class="sxs-lookup"><span data-stu-id="d7b80-645">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="d7b80-646">Os resultados não são materializados automaticamente e devem ser lido do leitor de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-646">Results are not automatically materialized, and must be read from the data reader.</span></span>

### <a name="65-sqlquery-and-executestorequery"></a><span data-ttu-id="d7b80-647">6.5 SqlQuery e ExecuteStoreQuery</span><span class="sxs-lookup"><span data-stu-id="d7b80-647">6.5       SqlQuery and ExecuteStoreQuery</span></span>

<span data-ttu-id="d7b80-648">SqlQuery no banco de dados:</span><span class="sxs-lookup"><span data-stu-id="d7b80-648">SqlQuery on Database:</span></span>

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

<span data-ttu-id="d7b80-649">SqlQuery no DbSet:</span><span class="sxs-lookup"><span data-stu-id="d7b80-649">SqlQuery on DbSet:</span></span>

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

<span data-ttu-id="d7b80-650">ExecyteStoreQuery:</span><span class="sxs-lookup"><span data-stu-id="d7b80-650">ExecyteStoreQuery:</span></span>

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

<span data-ttu-id="d7b80-651">**Profissionais**</span><span class="sxs-lookup"><span data-stu-id="d7b80-651">**Pros**</span></span>

-   <span data-ttu-id="d7b80-652">Geralmente, desempenho mais rápido, pois o compilador de plano é ignorado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-652">Generally fastest performance since plan compiler is bypassed.</span></span>
-   <span data-ttu-id="d7b80-653">Objetos totalmente materializados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-653">Fully materialized objects.</span></span>
-   <span data-ttu-id="d7b80-654">Adequado para operações de CUD quando usados a partir o DbSet.</span><span class="sxs-lookup"><span data-stu-id="d7b80-654">Suitable for CUD operations when used from the DbSet.</span></span>

<span data-ttu-id="d7b80-655">**Contras**</span><span class="sxs-lookup"><span data-stu-id="d7b80-655">**Cons**</span></span>

-   <span data-ttu-id="d7b80-656">Consulta é textual e sujeito a erros.</span><span class="sxs-lookup"><span data-stu-id="d7b80-656">Query is textual and error prone.</span></span>
-   <span data-ttu-id="d7b80-657">Consulta está ligada a um back-end específico usando a semântica do repositório em vez de semântica conceitual.</span><span class="sxs-lookup"><span data-stu-id="d7b80-657">Query is tied to a specific backend by using store semantics instead of conceptual semantics.</span></span>
-   <span data-ttu-id="d7b80-658">Quando a herança está presente, consulta artesanal precisa levar em conta condições de mapeamento para o tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-658">When inheritance is present, handcrafted query needs to account for mapping conditions for the type requested.</span></span>

### <a name="66-compiledquery"></a><span data-ttu-id="d7b80-659">6.6 CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="d7b80-659">6.6       CompiledQuery</span></span>

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

<span data-ttu-id="d7b80-660">**Profissionais**</span><span class="sxs-lookup"><span data-stu-id="d7b80-660">**Pros**</span></span>

-   <span data-ttu-id="d7b80-661">Fornece até uma melhoria de desempenho de % 7 em consultas LINQ regulares.</span><span class="sxs-lookup"><span data-stu-id="d7b80-661">Provides up to a 7% performance improvement over regular LINQ queries.</span></span>
-   <span data-ttu-id="d7b80-662">Objetos totalmente materializados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-662">Fully materialized objects.</span></span>
-   <span data-ttu-id="d7b80-663">Adequado para operações CUD.</span><span class="sxs-lookup"><span data-stu-id="d7b80-663">Suitable for CUD operations.</span></span>

<span data-ttu-id="d7b80-664">**Contras**</span><span class="sxs-lookup"><span data-stu-id="d7b80-664">**Cons**</span></span>

-   <span data-ttu-id="d7b80-665">Maior complexidade e sobrecarga de programação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-665">Increased complexity and programming overhead.</span></span>
-   <span data-ttu-id="d7b80-666">A melhoria de desempenho é perdida quando a composição na parte superior de uma consulta compilada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-666">The performance improvement is lost when composing on top of a compiled query.</span></span>
-   <span data-ttu-id="d7b80-667">Algumas consultas LINQ não podem ser gravadas como um CompiledQuery - por exemplo, as projeções de tipos anônimos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-667">Some LINQ queries can't be written as a CompiledQuery - for example, projections of anonymous types.</span></span>

### <a name="67-performance-comparison-of-different-query-options"></a><span data-ttu-id="d7b80-668">6.7 comparação de desempenho de das opções de consulta diferentes</span><span class="sxs-lookup"><span data-stu-id="d7b80-668">6.7       Performance Comparison of different query options</span></span>

<span data-ttu-id="d7b80-669">Microbenchmarks simples em que a criação de contexto não tenha sido programada foram inseridos para o teste.</span><span class="sxs-lookup"><span data-stu-id="d7b80-669">Simple microbenchmarks where the context creation was not timed were put to the test.</span></span> <span data-ttu-id="d7b80-670">Medimos consultando 5000 vezes para um conjunto de entidades não armazenado em cache em um ambiente controlado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-670">We measured querying 5000 times for a set of non-cached entities in a controlled environment.</span></span> <span data-ttu-id="d7b80-671">Esses números devem ser criados com um aviso: eles não refletem os números reais produzidos por um aplicativo, mas em vez disso, eles são uma medida bastante precisa da quantidade de uma diferença de desempenho que não há quando as opções de consulta diferentes são comparadas maçãs-com-maçãs, excluindo o custo de criação de um novo contexto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-671">These numbers are to be taken with a warning: they do not reflect actual numbers produced by an application, but instead they are a very accurate measurement of how much of a performance difference there is when different querying options are compared apples-to-apples, excluding the cost of creating a new context.</span></span>

| <span data-ttu-id="d7b80-672">EF</span><span class="sxs-lookup"><span data-stu-id="d7b80-672">EF</span></span>  | <span data-ttu-id="d7b80-673">Teste</span><span class="sxs-lookup"><span data-stu-id="d7b80-673">Test</span></span>                                 | <span data-ttu-id="d7b80-674">Tempo (ms)</span><span class="sxs-lookup"><span data-stu-id="d7b80-674">Time (ms)</span></span> | <span data-ttu-id="d7b80-675">Memória</span><span class="sxs-lookup"><span data-stu-id="d7b80-675">Memory</span></span>   |
|:----|:-------------------------------------|:----------|:---------|
| <span data-ttu-id="d7b80-676">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-676">EF5</span></span> | <span data-ttu-id="d7b80-677">ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="d7b80-677">ObjectContext ESQL</span></span>                   | <span data-ttu-id="d7b80-678">2414</span><span class="sxs-lookup"><span data-stu-id="d7b80-678">2414</span></span>      | <span data-ttu-id="d7b80-679">38801408</span><span class="sxs-lookup"><span data-stu-id="d7b80-679">38801408</span></span> |
| <span data-ttu-id="d7b80-680">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-680">EF5</span></span> | <span data-ttu-id="d7b80-681">Consulta de Linq ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-681">ObjectContext Linq Query</span></span>             | <span data-ttu-id="d7b80-682">2692</span><span class="sxs-lookup"><span data-stu-id="d7b80-682">2692</span></span>      | <span data-ttu-id="d7b80-683">38277120</span><span class="sxs-lookup"><span data-stu-id="d7b80-683">38277120</span></span> |
| <span data-ttu-id="d7b80-684">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-684">EF5</span></span> | <span data-ttu-id="d7b80-685">Nenhum rastreamento de consulta do Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-685">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="d7b80-686">2818</span><span class="sxs-lookup"><span data-stu-id="d7b80-686">2818</span></span>      | <span data-ttu-id="d7b80-687">41840640</span><span class="sxs-lookup"><span data-stu-id="d7b80-687">41840640</span></span> |
| <span data-ttu-id="d7b80-688">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-688">EF5</span></span> | <span data-ttu-id="d7b80-689">Consulta de Linq DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-689">DbContext Linq Query</span></span>                 | <span data-ttu-id="d7b80-690">2930</span><span class="sxs-lookup"><span data-stu-id="d7b80-690">2930</span></span>      | <span data-ttu-id="d7b80-691">41771008</span><span class="sxs-lookup"><span data-stu-id="d7b80-691">41771008</span></span> |
| <span data-ttu-id="d7b80-692">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-692">EF5</span></span> | <span data-ttu-id="d7b80-693">Nenhum rastreamento de consulta do Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-693">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="d7b80-694">3013</span><span class="sxs-lookup"><span data-stu-id="d7b80-694">3013</span></span>      | <span data-ttu-id="d7b80-695">38412288</span><span class="sxs-lookup"><span data-stu-id="d7b80-695">38412288</span></span> |
|     |                                      |           |          |
| <span data-ttu-id="d7b80-696">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-696">EF6</span></span> | <span data-ttu-id="d7b80-697">ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="d7b80-697">ObjectContext ESQL</span></span>                   | <span data-ttu-id="d7b80-698">2059</span><span class="sxs-lookup"><span data-stu-id="d7b80-698">2059</span></span>      | <span data-ttu-id="d7b80-699">46039040</span><span class="sxs-lookup"><span data-stu-id="d7b80-699">46039040</span></span> |
| <span data-ttu-id="d7b80-700">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-700">EF6</span></span> | <span data-ttu-id="d7b80-701">Consulta de Linq ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-701">ObjectContext Linq Query</span></span>             | <span data-ttu-id="d7b80-702">3074</span><span class="sxs-lookup"><span data-stu-id="d7b80-702">3074</span></span>      | <span data-ttu-id="d7b80-703">45248512</span><span class="sxs-lookup"><span data-stu-id="d7b80-703">45248512</span></span> |
| <span data-ttu-id="d7b80-704">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-704">EF6</span></span> | <span data-ttu-id="d7b80-705">Nenhum rastreamento de consulta do Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-705">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="d7b80-706">3125</span><span class="sxs-lookup"><span data-stu-id="d7b80-706">3125</span></span>      | <span data-ttu-id="d7b80-707">47575040</span><span class="sxs-lookup"><span data-stu-id="d7b80-707">47575040</span></span> |
| <span data-ttu-id="d7b80-708">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-708">EF6</span></span> | <span data-ttu-id="d7b80-709">Consulta de Linq DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-709">DbContext Linq Query</span></span>                 | <span data-ttu-id="d7b80-710">3420</span><span class="sxs-lookup"><span data-stu-id="d7b80-710">3420</span></span>      | <span data-ttu-id="d7b80-711">47652864</span><span class="sxs-lookup"><span data-stu-id="d7b80-711">47652864</span></span> |
| <span data-ttu-id="d7b80-712">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-712">EF6</span></span> | <span data-ttu-id="d7b80-713">Nenhum rastreamento de consulta do Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-713">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="d7b80-714">3593</span><span class="sxs-lookup"><span data-stu-id="d7b80-714">3593</span></span>      | <span data-ttu-id="d7b80-715">45260800</span><span class="sxs-lookup"><span data-stu-id="d7b80-715">45260800</span></span> |

![EF5 microbenchmarks, 5000 iterações quentes](~/ef6/media/ef5micro5000warm.png)

![EF6 microbenchmarks, 5000 iterações quentes](~/ef6/media/ef6micro5000warm.png)

<span data-ttu-id="d7b80-718">Microbenchmarks são muito sensíveis a pequenas alterações no código.</span><span class="sxs-lookup"><span data-stu-id="d7b80-718">Microbenchmarks are very sensitive to small changes in the code.</span></span> <span data-ttu-id="d7b80-719">Nesse caso, a diferença entre os custos do Entity Framework 5 e o Entity Framework 6 são devido à adição de [interceptação](~/ef6/fundamentals/logging-and-interception.md) e [melhorias transacionais](~/ef6/saving/transactions.md).</span><span class="sxs-lookup"><span data-stu-id="d7b80-719">In this case, the difference between the costs of Entity Framework 5 and Entity Framework 6 are due to the addition of [interception](~/ef6/fundamentals/logging-and-interception.md) and [transactional improvements](~/ef6/saving/transactions.md).</span></span> <span data-ttu-id="d7b80-720">Esses números microbenchmarks, no entanto, são uma visão elevada em um fragmento muito pequena do que o Entity Framework faz.</span><span class="sxs-lookup"><span data-stu-id="d7b80-720">These microbenchmarks numbers, however, are an amplified vision into a very small fragment of what Entity Framework does.</span></span> <span data-ttu-id="d7b80-721">Cenários do mundo real de consultas passivos não deverá ver uma regressão de desempenho ao atualizar do Entity Framework 5 para o Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="d7b80-721">Real-world scenarios of warm queries should not see a performance regression when upgrading from Entity Framework 5 to Entity Framework 6.</span></span>

<span data-ttu-id="d7b80-722">Para comparar o desempenho das opções de consulta diferentes no mundo real, nós criamos 5 variações de teste separado, em que podemos usar uma opção de consulta diferente para selecionar todos os produtos cujo nome de categoria é "Bebidas".</span><span class="sxs-lookup"><span data-stu-id="d7b80-722">To compare the real-world performance of the different query options, we created 5 separate test variations where we use a different query option to select all products whose category name is "Beverages".</span></span> <span data-ttu-id="d7b80-723">Cada iteração inclui o custo da criação do contexto e o custo de materializar entidades retornadas tudo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-723">Each iteration includes the cost of creating the context, and the cost of materializing all returned entities.</span></span> <span data-ttu-id="d7b80-724">10 iterações são executadas untimed antes de fazer a soma de atingiu o tempo limitado de 1000 iterações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-724">10 iterations are run untimed before taking the sum of 1000 timed iterations.</span></span> <span data-ttu-id="d7b80-725">Os resultados mostrados são a execução mediana tirada 5 execuções de cada teste.</span><span class="sxs-lookup"><span data-stu-id="d7b80-725">The results shown are the median run taken from 5 runs of each test.</span></span> <span data-ttu-id="d7b80-726">Para obter mais informações, consulte o Apêndice B, que inclui o código de teste.</span><span class="sxs-lookup"><span data-stu-id="d7b80-726">For more information, see Appendix B which includes the code for the test.</span></span>

| <span data-ttu-id="d7b80-727">EF</span><span class="sxs-lookup"><span data-stu-id="d7b80-727">EF</span></span>  | <span data-ttu-id="d7b80-728">Teste</span><span class="sxs-lookup"><span data-stu-id="d7b80-728">Test</span></span>                                        | <span data-ttu-id="d7b80-729">Tempo (ms)</span><span class="sxs-lookup"><span data-stu-id="d7b80-729">Time (ms)</span></span> | <span data-ttu-id="d7b80-730">Memória</span><span class="sxs-lookup"><span data-stu-id="d7b80-730">Memory</span></span>   |
|:----|:--------------------------------------------|:----------|:---------|
| <span data-ttu-id="d7b80-731">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-731">EF5</span></span> | <span data-ttu-id="d7b80-732">Comando de entidade de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-732">ObjectContext Entity Command</span></span>                | <span data-ttu-id="d7b80-733">621</span><span class="sxs-lookup"><span data-stu-id="d7b80-733">621</span></span>       | <span data-ttu-id="d7b80-734">39350272</span><span class="sxs-lookup"><span data-stu-id="d7b80-734">39350272</span></span> |
| <span data-ttu-id="d7b80-735">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-735">EF5</span></span> | <span data-ttu-id="d7b80-736">Consulta Sql de DbContext no banco de dados</span><span class="sxs-lookup"><span data-stu-id="d7b80-736">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="d7b80-737">825</span><span class="sxs-lookup"><span data-stu-id="d7b80-737">825</span></span>       | <span data-ttu-id="d7b80-738">37519360</span><span class="sxs-lookup"><span data-stu-id="d7b80-738">37519360</span></span> |
| <span data-ttu-id="d7b80-739">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-739">EF5</span></span> | <span data-ttu-id="d7b80-740">Consulta de Store de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-740">ObjectContext Store Query</span></span>                   | <span data-ttu-id="d7b80-741">878</span><span class="sxs-lookup"><span data-stu-id="d7b80-741">878</span></span>       | <span data-ttu-id="d7b80-742">39460864</span><span class="sxs-lookup"><span data-stu-id="d7b80-742">39460864</span></span> |
| <span data-ttu-id="d7b80-743">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-743">EF5</span></span> | <span data-ttu-id="d7b80-744">Nenhum rastreamento de consulta do Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-744">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="d7b80-745">969</span><span class="sxs-lookup"><span data-stu-id="d7b80-745">969</span></span>       | <span data-ttu-id="d7b80-746">38293504</span><span class="sxs-lookup"><span data-stu-id="d7b80-746">38293504</span></span> |
| <span data-ttu-id="d7b80-747">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-747">EF5</span></span> | <span data-ttu-id="d7b80-748">ObjectContext Entity Sql usando o objeto de consulta</span><span class="sxs-lookup"><span data-stu-id="d7b80-748">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="d7b80-749">1089</span><span class="sxs-lookup"><span data-stu-id="d7b80-749">1089</span></span>      | <span data-ttu-id="d7b80-750">38981632</span><span class="sxs-lookup"><span data-stu-id="d7b80-750">38981632</span></span> |
| <span data-ttu-id="d7b80-751">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-751">EF5</span></span> | <span data-ttu-id="d7b80-752">Consulta compilada do ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-752">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="d7b80-753">1099</span><span class="sxs-lookup"><span data-stu-id="d7b80-753">1099</span></span>      | <span data-ttu-id="d7b80-754">38682624</span><span class="sxs-lookup"><span data-stu-id="d7b80-754">38682624</span></span> |
| <span data-ttu-id="d7b80-755">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-755">EF5</span></span> | <span data-ttu-id="d7b80-756">Consulta de Linq ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-756">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="d7b80-757">1152</span><span class="sxs-lookup"><span data-stu-id="d7b80-757">1152</span></span>      | <span data-ttu-id="d7b80-758">38178816</span><span class="sxs-lookup"><span data-stu-id="d7b80-758">38178816</span></span> |
| <span data-ttu-id="d7b80-759">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-759">EF5</span></span> | <span data-ttu-id="d7b80-760">Nenhum rastreamento de consulta do Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-760">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="d7b80-761">1208</span><span class="sxs-lookup"><span data-stu-id="d7b80-761">1208</span></span>      | <span data-ttu-id="d7b80-762">41803776</span><span class="sxs-lookup"><span data-stu-id="d7b80-762">41803776</span></span> |
| <span data-ttu-id="d7b80-763">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-763">EF5</span></span> | <span data-ttu-id="d7b80-764">Consulta Sql de DbContext no DbSet</span><span class="sxs-lookup"><span data-stu-id="d7b80-764">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="d7b80-765">1414</span><span class="sxs-lookup"><span data-stu-id="d7b80-765">1414</span></span>      | <span data-ttu-id="d7b80-766">37982208</span><span class="sxs-lookup"><span data-stu-id="d7b80-766">37982208</span></span> |
| <span data-ttu-id="d7b80-767">EF5</span><span class="sxs-lookup"><span data-stu-id="d7b80-767">EF5</span></span> | <span data-ttu-id="d7b80-768">Consulta de Linq DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-768">DbContext Linq Query</span></span>                        | <span data-ttu-id="d7b80-769">1574</span><span class="sxs-lookup"><span data-stu-id="d7b80-769">1574</span></span>      | <span data-ttu-id="d7b80-770">41738240</span><span class="sxs-lookup"><span data-stu-id="d7b80-770">41738240</span></span> |
|     |                                             |           |          |
| <span data-ttu-id="d7b80-771">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-771">EF6</span></span> | <span data-ttu-id="d7b80-772">Comando de entidade de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-772">ObjectContext Entity Command</span></span>                | <span data-ttu-id="d7b80-773">480</span><span class="sxs-lookup"><span data-stu-id="d7b80-773">480</span></span>       | <span data-ttu-id="d7b80-774">47247360</span><span class="sxs-lookup"><span data-stu-id="d7b80-774">47247360</span></span> |
| <span data-ttu-id="d7b80-775">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-775">EF6</span></span> | <span data-ttu-id="d7b80-776">Consulta de Store de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-776">ObjectContext Store Query</span></span>                   | <span data-ttu-id="d7b80-777">493</span><span class="sxs-lookup"><span data-stu-id="d7b80-777">493</span></span>       | <span data-ttu-id="d7b80-778">46739456</span><span class="sxs-lookup"><span data-stu-id="d7b80-778">46739456</span></span> |
| <span data-ttu-id="d7b80-779">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-779">EF6</span></span> | <span data-ttu-id="d7b80-780">Consulta Sql de DbContext no banco de dados</span><span class="sxs-lookup"><span data-stu-id="d7b80-780">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="d7b80-781">614</span><span class="sxs-lookup"><span data-stu-id="d7b80-781">614</span></span>       | <span data-ttu-id="d7b80-782">41607168</span><span class="sxs-lookup"><span data-stu-id="d7b80-782">41607168</span></span> |
| <span data-ttu-id="d7b80-783">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-783">EF6</span></span> | <span data-ttu-id="d7b80-784">Nenhum rastreamento de consulta do Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-784">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="d7b80-785">684</span><span class="sxs-lookup"><span data-stu-id="d7b80-785">684</span></span>       | <span data-ttu-id="d7b80-786">46333952</span><span class="sxs-lookup"><span data-stu-id="d7b80-786">46333952</span></span> |
| <span data-ttu-id="d7b80-787">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-787">EF6</span></span> | <span data-ttu-id="d7b80-788">ObjectContext Entity Sql usando o objeto de consulta</span><span class="sxs-lookup"><span data-stu-id="d7b80-788">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="d7b80-789">767</span><span class="sxs-lookup"><span data-stu-id="d7b80-789">767</span></span>       | <span data-ttu-id="d7b80-790">48865280</span><span class="sxs-lookup"><span data-stu-id="d7b80-790">48865280</span></span> |
| <span data-ttu-id="d7b80-791">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-791">EF6</span></span> | <span data-ttu-id="d7b80-792">Consulta compilada do ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-792">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="d7b80-793">788</span><span class="sxs-lookup"><span data-stu-id="d7b80-793">788</span></span>       | <span data-ttu-id="d7b80-794">48467968</span><span class="sxs-lookup"><span data-stu-id="d7b80-794">48467968</span></span> |
| <span data-ttu-id="d7b80-795">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-795">EF6</span></span> | <span data-ttu-id="d7b80-796">Nenhum rastreamento de consulta do Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-796">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="d7b80-797">878</span><span class="sxs-lookup"><span data-stu-id="d7b80-797">878</span></span>       | <span data-ttu-id="d7b80-798">47554560</span><span class="sxs-lookup"><span data-stu-id="d7b80-798">47554560</span></span> |
| <span data-ttu-id="d7b80-799">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-799">EF6</span></span> | <span data-ttu-id="d7b80-800">Consulta de Linq ObjectContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-800">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="d7b80-801">953</span><span class="sxs-lookup"><span data-stu-id="d7b80-801">953</span></span>       | <span data-ttu-id="d7b80-802">47632384</span><span class="sxs-lookup"><span data-stu-id="d7b80-802">47632384</span></span> |
| <span data-ttu-id="d7b80-803">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-803">EF6</span></span> | <span data-ttu-id="d7b80-804">Consulta Sql de DbContext no DbSet</span><span class="sxs-lookup"><span data-stu-id="d7b80-804">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="d7b80-805">1023</span><span class="sxs-lookup"><span data-stu-id="d7b80-805">1023</span></span>      | <span data-ttu-id="d7b80-806">41992192</span><span class="sxs-lookup"><span data-stu-id="d7b80-806">41992192</span></span> |
| <span data-ttu-id="d7b80-807">EF6</span><span class="sxs-lookup"><span data-stu-id="d7b80-807">EF6</span></span> | <span data-ttu-id="d7b80-808">Consulta de Linq DbContext</span><span class="sxs-lookup"><span data-stu-id="d7b80-808">DbContext Linq Query</span></span>                        | <span data-ttu-id="d7b80-809">1290</span><span class="sxs-lookup"><span data-stu-id="d7b80-809">1290</span></span>      | <span data-ttu-id="d7b80-810">47529984</span><span class="sxs-lookup"><span data-stu-id="d7b80-810">47529984</span></span> |


![Iterações do EF5 passiva consulta 1000](~/ef6/media/ef5warmquery1000.png)

![Iterações do EF6 passiva consulta 1000](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> <span data-ttu-id="d7b80-813">Para fins de integridade, incluímos uma variação onde executamos uma consulta Entity SQL em um EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="d7b80-813">For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span></span> <span data-ttu-id="d7b80-814">No entanto, porque os resultados não são materializados para tais consultas, a comparação não é necessariamente igual para igual.</span><span class="sxs-lookup"><span data-stu-id="d7b80-814">However, because results are not materialized for such queries, the comparison isn't necessarily apples-to-apples.</span></span> <span data-ttu-id="d7b80-815">O teste inclui uma aproximação para materializar tentar fazer a comparação obter.</span><span class="sxs-lookup"><span data-stu-id="d7b80-815">The test includes a close approximation to materializing to try making the comparison fairer.</span></span>

<span data-ttu-id="d7b80-816">Nesse caso de ponta a ponta, o Entity Framework 6 supera o Entity Framework 5 devido aos aprimoramentos de desempenho feitos em várias partes da pilha, incluindo uma inicialização muito mais leve do DbContext e mais rápido MetadataCollection&lt;T&gt; pesquisas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-816">In this end-to-end case, Entity Framework 6 outperforms Entity Framework 5 due to performance improvements made on several parts of the stack, including a much lighter DbContext initialization and faster MetadataCollection&lt;T&gt; lookups.</span></span>

## <a name="7-design-time-performance-considerations"></a><span data-ttu-id="d7b80-817">Considerações de desempenho de tempo de design 7</span><span class="sxs-lookup"><span data-stu-id="d7b80-817">7 Design time performance considerations</span></span>

### <a name="71-inheritance-strategies"></a><span data-ttu-id="d7b80-818">7.1 estratégias de herança</span><span class="sxs-lookup"><span data-stu-id="d7b80-818">7.1       Inheritance Strategies</span></span>

<span data-ttu-id="d7b80-819">Outra consideração de desempenho ao usar o Entity Framework é a estratégia de herança que você usar.</span><span class="sxs-lookup"><span data-stu-id="d7b80-819">Another performance consideration when using Entity Framework is the inheritance strategy you use.</span></span> <span data-ttu-id="d7b80-820">Entity Framework dá suporte a 3 tipos básicos de herança e suas combinações:</span><span class="sxs-lookup"><span data-stu-id="d7b80-820">Entity Framework supports 3 basic types of inheritance and their combinations:</span></span>

-   <span data-ttu-id="d7b80-821">Tabela por hierarquia (TPH) – em que cada herança definida mapas em uma tabela com uma coluna discriminatória para indicar qual tipo específico na hierarquia está sendo representada na linha.</span><span class="sxs-lookup"><span data-stu-id="d7b80-821">Table per Hierarchy (TPH) – where each inheritance set maps to a table with a discriminator column to indicate which particular type in the hierarchy is being represented in the row.</span></span>
-   <span data-ttu-id="d7b80-822">Tabela por tipo (TPT) – em que cada tipo tem sua própria tabela no banco de dados; as tabelas filho apenas definem as colunas que não contém a tabela pai.</span><span class="sxs-lookup"><span data-stu-id="d7b80-822">Table per Type (TPT) – where each type has its own table in the database; the child tables only define the columns that the parent table doesn’t contain.</span></span>
-   <span data-ttu-id="d7b80-823">Tabela por classe (TPC) – em que cada tipo tem sua própria tabela completa no banco de dados; as tabelas filho definem todos os campos, incluindo aqueles definidos em tipos pai.</span><span class="sxs-lookup"><span data-stu-id="d7b80-823">Table per Class (TPC) – where each type has its own full table in the database; the child tables define all their fields, including those defined in parent types.</span></span>

<span data-ttu-id="d7b80-824">Se seu modelo usa herança TPT, as consultas que são geradas será mais complexas do que aquelas que são gerados com as outras estratégias de herança, que podem resultar em tempos de execução no repositório.</span><span class="sxs-lookup"><span data-stu-id="d7b80-824">If your model uses TPT inheritance, the queries which are generated will be more complex than those that are generated with the other inheritance strategies, which may result on longer execution times on the store.</span></span><span data-ttu-id="d7b80-825">  Geralmente, levará mais tempo para gerar consultas em um modelo de TPT e materializar os objetos resultantes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-825">  It will generally take longer to generate queries over a TPT model, and to materialize the resulting objects.</span></span>

<span data-ttu-id="d7b80-826">Consulte as "Considerações de desempenho ao usar herança TPT (tabela por tipo) no Entity Framework" postagem de blog do MSDN: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-826">See the "Performance Considerations when using TPT (Table per Type) Inheritance in the Entity Framework" MSDN blog post: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span></span>

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a><span data-ttu-id="d7b80-827">7.1.1 evitar TPT em aplicativos Model First ou Code First</span><span class="sxs-lookup"><span data-stu-id="d7b80-827">7.1.1       Avoiding TPT in Model First or Code First applications</span></span>

<span data-ttu-id="d7b80-828">Quando você cria um modelo em um banco de dados existente que tenha um esquema TPT, você não tem muitas opções.</span><span class="sxs-lookup"><span data-stu-id="d7b80-828">When you create a model over an existing database that has a TPT schema, you don't have many options.</span></span> <span data-ttu-id="d7b80-829">Mas, ao criar um aplicativo usando Model First ou Code First, você deve evitar herança TPT para questões de desempenho.</span><span class="sxs-lookup"><span data-stu-id="d7b80-829">But when creating an application using Model First or Code First, you should avoid TPT inheritance for performance concerns.</span></span>

<span data-ttu-id="d7b80-830">Quando você usa o Model First no Entity Designer de assistente, você obterá TPT para qualquer herança em seu modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-830">When you use Model First in the Entity Designer Wizard, you will get TPT for any inheritance in your model.</span></span> <span data-ttu-id="d7b80-831">Se você quiser mudar para uma estratégia de herança TPH com Model First, você pode usar o "Entity Designer de banco de dados Generation Power Pack" disponíveis na Galeria do Visual Studio ( \< http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span><span class="sxs-lookup"><span data-stu-id="d7b80-831">If you want to switch to a TPH inheritance strategy with Model First, you can use the "Entity Designer Database Generation Power Pack" available from the Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span></span>

<span data-ttu-id="d7b80-832">Ao usar o Code First para configurar o mapeamento de um modelo com a herança, o EF usará TPH por padrão, portanto todas as entidades na hierarquia de herança serão mapeadas para a mesma tabela.</span><span class="sxs-lookup"><span data-stu-id="d7b80-832">When using Code First to configure the mapping of a model with inheritance, EF will use TPH by default, therefore all entities in the inheritance hierarchy will be mapped to the same table.</span></span> <span data-ttu-id="d7b80-833">Consulte a seção "Mapeamento com a API Fluent" do artigo "Código primeiro na entidade Framework4.1" na MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-833">See the "Mapping with the Fluent API" section of the "Code First in Entity Framework4.1" article in MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) for more details.</span></span>

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a><span data-ttu-id="d7b80-834">7.2 para atualizar do EF4 para melhorar a geração de modelo de tempo</span><span class="sxs-lookup"><span data-stu-id="d7b80-834">7.2       Upgrading from EF4 to improve model generation time</span></span>

<span data-ttu-id="d7b80-835">Uma melhoria específica do SQL Server para o algoritmo que gera a camada de armazenamento (SSDL) do modelo está disponível no Entity Framework 5 e 6 e como uma atualização para o Entity Framework 4 ao Visual Studio 2010 SP1 está instalado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-835">A SQL Server-specific improvement to the algorithm that generates the store-layer (SSDL) of the model is available in Entity Framework 5 and 6, and as an update to Entity Framework 4 when Visual Studio 2010 SP1 is installed.</span></span> <span data-ttu-id="d7b80-836">Os resultados de teste a seguir demonstram a melhoria ao gerar um modelo muito grande, neste caso, o modelo Navision.</span><span class="sxs-lookup"><span data-stu-id="d7b80-836">The following test results demonstrate the improvement when generating a very big model, in this case the Navision model.</span></span> <span data-ttu-id="d7b80-837">Consulte o Apêndice C para obter mais detalhes sobre ele.</span><span class="sxs-lookup"><span data-stu-id="d7b80-837">See Appendix C for more details about it.</span></span>

<span data-ttu-id="d7b80-838">O modelo contém conjuntos de entidade 1005 e 4227 associações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-838">The model contains 1005 entity sets and 4227 association sets.</span></span>

| <span data-ttu-id="d7b80-839">Configuração</span><span class="sxs-lookup"><span data-stu-id="d7b80-839">Configuration</span></span>                              | <span data-ttu-id="d7b80-840">Divisão de tempo consumido</span><span class="sxs-lookup"><span data-stu-id="d7b80-840">Breakdown of time consumed</span></span>                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="d7b80-841">Visual Studio 2010, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="d7b80-841">Visual Studio 2010, Entity Framework 4</span></span>     | <span data-ttu-id="d7b80-842">Geração de SSDL: 2 hr 27 min</span><span class="sxs-lookup"><span data-stu-id="d7b80-842">SSDL Generation: 2 hr 27 min</span></span> <br/> <span data-ttu-id="d7b80-843">Geração de mapeamento: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-843">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-844">Geração de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-844">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-845">Geração de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-845">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-846">Geração de exibição: 2 h 14 min</span><span class="sxs-lookup"><span data-stu-id="d7b80-846">View Generation: 2 h 14 min</span></span> |
| <span data-ttu-id="d7b80-847">Visual Studio 2010 SP1, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="d7b80-847">Visual Studio 2010 SP1, Entity Framework 4</span></span> | <span data-ttu-id="d7b80-848">Geração de SSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-848">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-849">Geração de mapeamento: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-849">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-850">Geração de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-850">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-851">Geração de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-851">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-852">Geração de exibição: 1 hr 53 min</span><span class="sxs-lookup"><span data-stu-id="d7b80-852">View Generation: 1 hr 53 min</span></span>   |
| <span data-ttu-id="d7b80-853">Visual Studio 2013, o Entity Framework 5</span><span class="sxs-lookup"><span data-stu-id="d7b80-853">Visual Studio 2013, Entity Framework 5</span></span>     | <span data-ttu-id="d7b80-854">Geração de SSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-854">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-855">Geração de mapeamento: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-855">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-856">Geração de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-856">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-857">Geração de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-857">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-858">Geração de exibição: minutos de 65</span><span class="sxs-lookup"><span data-stu-id="d7b80-858">View Generation: 65 minutes</span></span>    |
| <span data-ttu-id="d7b80-859">Visual Studio 2013, Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="d7b80-859">Visual Studio 2013, Entity Framework 6</span></span>     | <span data-ttu-id="d7b80-860">Geração de SSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-860">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-861">Geração de mapeamento: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-861">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-862">Geração de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-862">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-863">Geração de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="d7b80-863">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="d7b80-864">Geração de exibição: 28 segundos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-864">View Generation: 28 seconds.</span></span>   |


<span data-ttu-id="d7b80-865">Vale a pena observar que ao gerar o SSDL, a carga é quase que totalmente gasto no SQL Server, enquanto a máquina de desenvolvimento do cliente está aguardando ocioso para resultados antes de voltar do servidor.</span><span class="sxs-lookup"><span data-stu-id="d7b80-865">It's worth noting that when generating the SSDL, the load is almost entirely spent on the SQL Server, while the client development machine is waiting idle for results to come back from the server.</span></span> <span data-ttu-id="d7b80-866">Os DBAs particularmente devem apreciar essa melhoria.</span><span class="sxs-lookup"><span data-stu-id="d7b80-866">DBAs should particularly appreciate this improvement.</span></span> <span data-ttu-id="d7b80-867">Também vale a pena observar que, essencialmente, todo o custo de geração de modelo ocorre na geração de exibição agora.</span><span class="sxs-lookup"><span data-stu-id="d7b80-867">It's also worth noting that essentially the entire cost of model generation takes place in View Generation now.</span></span>

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a><span data-ttu-id="d7b80-868">7.3 dividir grandes modelos com o banco de dados pela primeira vez e Model First</span><span class="sxs-lookup"><span data-stu-id="d7b80-868">7.3       Splitting Large Models with Database First and Model First</span></span>

<span data-ttu-id="d7b80-869">À medida que aumenta de tamanho do modelo, a superfície do designer fica confuso e difícil de usar.</span><span class="sxs-lookup"><span data-stu-id="d7b80-869">As model size increases, the designer surface becomes cluttered and difficult to use.</span></span> <span data-ttu-id="d7b80-870">Normalmente, vamos considerar um modelo com mais de 300 entidades a serem muito grande para ser efetivamente usar o designer.</span><span class="sxs-lookup"><span data-stu-id="d7b80-870">We typically consider a model with more than 300 entities to be too large to effectively use the designer.</span></span> <span data-ttu-id="d7b80-871">A seguinte postagem de blog descreve as várias opções para a divisão de grandes modelos: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-871">The following blog post describes several options for splitting large models: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span></span>

<span data-ttu-id="d7b80-872">A postagem foi escrita para a primeira versão do Entity Framework, mas as etapas ainda se aplicam.</span><span class="sxs-lookup"><span data-stu-id="d7b80-872">The post was written for the first version of Entity Framework, but the steps still apply.</span></span>

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a><span data-ttu-id="d7b80-873">7.4 Considerações sobre desempenho de com o controle de fonte de dados de entidade</span><span class="sxs-lookup"><span data-stu-id="d7b80-873">7.4       Performance considerations with the Entity Data Source Control</span></span>

<span data-ttu-id="d7b80-874">Já vimos casos em testes de estresse e desempenho com multithread em que o desempenho de um aplicativo web usando o controle EntityDataSource cai significativamente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-874">We've seen cases in multi-threaded performance and stress tests where the performance of a web application using the EntityDataSource Control deteriorates significantly.</span></span> <span data-ttu-id="d7b80-875">A causa subjacente é que o EntityDataSource chama repetidamente MetadataWorkspace.LoadFromAssembly em assemblies referenciados pelo aplicativo Web para descobrir os tipos a serem usados como entidades.</span><span class="sxs-lookup"><span data-stu-id="d7b80-875">The underlying cause is that the EntityDataSource repeatedly calls MetadataWorkspace.LoadFromAssembly on the assemblies referenced by the Web application to discover the types to be used as entities.</span></span>

<span data-ttu-id="d7b80-876">A solução é definir o ContextTypeName do EntityDataSource como o nome do tipo de sua classe derivada de ObjectContext.</span><span class="sxs-lookup"><span data-stu-id="d7b80-876">The solution is to set the ContextTypeName of the EntityDataSource to the type name of your derived ObjectContext class.</span></span> <span data-ttu-id="d7b80-877">Isso desativa o mecanismo que examina todos os assemblies referenciados para os tipos de entidade.</span><span class="sxs-lookup"><span data-stu-id="d7b80-877">This turns off the mechanism that scans all referenced assemblies for entity types.</span></span>

<span data-ttu-id="d7b80-878">Definir o campo ContextTypeName também impede que um problema funcional em que o EntityDataSource no .NET 4.0 gera uma ReflectionTypeLoadException quando ele não é possível carregar um tipo de um assembly por meio de reflexão.</span><span class="sxs-lookup"><span data-stu-id="d7b80-878">Setting the ContextTypeName field also prevents a functional problem where the EntityDataSource in .NET 4.0 throws a ReflectionTypeLoadException when it can't load a type from an assembly via reflection.</span></span> <span data-ttu-id="d7b80-879">Esse problema foi corrigido no .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="d7b80-879">This issue has been fixed in .NET 4.5.</span></span>

### <a name="75-poco-entities-and-change-tracking-proxies"></a><span data-ttu-id="d7b80-880">7.5 entidades POCO e proxies de controle de alterações</span><span class="sxs-lookup"><span data-stu-id="d7b80-880">7.5       POCO entities and change tracking proxies</span></span>

<span data-ttu-id="d7b80-881">Entity Framework permite que você use classes de dados personalizados junto com seu modelo de dados sem fazer nenhuma modificação às classes de dados em si.</span><span class="sxs-lookup"><span data-stu-id="d7b80-881">Entity Framework enables you to use custom data classes together with your data model without making any modifications to the data classes themselves.</span></span> <span data-ttu-id="d7b80-882">Isso significa que você pode usar "simples" objetos CLR (POCO), como objetos de domínio existente, com seu modelo de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-882">This means that you can use "plain-old" CLR objects (POCO), such as existing domain objects, with your data model.</span></span> <span data-ttu-id="d7b80-883">Essas classes de dados POCO (também conhecido como com ignorância de persistência de objetos), que são mapeados para entidades que são definidas em um modelo de dados, dão suporte à maioria da mesma consulta, inserir, atualizarem e excluir comportamentos como tipos de entidade que são gerados pelas ferramentas do modelo de dados de entidade.</span><span class="sxs-lookup"><span data-stu-id="d7b80-883">These POCO data classes (also known as persistence-ignorant objects), which are mapped to entities that are defined in a data model, support most of the same query, insert, update, and delete behaviors as entity types that are generated by the Entity Data Model tools.</span></span>

<span data-ttu-id="d7b80-884">Entity Framework também pode criar classes proxy derivadas de seus tipos de POCO, que são usados quando você deseja habilitar os recursos, como carregamento lento e automática controle de alterações em entidades POCO.</span><span class="sxs-lookup"><span data-stu-id="d7b80-884">Entity Framework can also create proxy classes derived from your POCO types, which are used when you want to enable features such as lazy loading and automatic change tracking on POCO entities.</span></span> <span data-ttu-id="d7b80-885">Suas classes POCO devem atender a certos requisitos para permitir que o Entity Framework para poderem usar proxies, conforme descrito aqui: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span><span class="sxs-lookup"><span data-stu-id="d7b80-885">Your POCO classes must meet certain requirements to allow Entity Framework to use proxies, as described here: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span></span>

<span data-ttu-id="d7b80-886">Proxies de controle de oportunidade notificará o Gerenciador de estado do objeto sempre que qualquer uma das propriedades das entidades tem seu valor alterado, para que o Entity Framework saiba o estado real das suas entidades o tempo todo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-886">Chance tracking proxies will notify the object state manager each time any of the properties of your entities has its value changed, so Entity Framework knows the actual state of your entities all the time.</span></span> <span data-ttu-id="d7b80-887">Isso é feito adicionando eventos de notificação para o corpo dos métodos setter de suas propriedades e ter o Gerenciador de estado do objeto tais eventos de processamento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-887">This is done by adding notification events to the body of the setter methods of your properties, and having the object state manager processing such events.</span></span> <span data-ttu-id="d7b80-888">Observe que a criação de um proxy entidade será normalmente ser mais caro do que criar uma entidade POCO não proxy devido ao conjunto de eventos criados pelo Entity Framework adicionado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-888">Note that creating a proxy entity will typically be more expensive than creating a non-proxy POCO entity due to the added set of events created by Entity Framework.</span></span>

<span data-ttu-id="d7b80-889">Quando uma entidade POCO não tem um proxy de controle de alterações, as alterações são encontradas, comparando o conteúdo das suas entidades em uma cópia de um estado salvo anterior.</span><span class="sxs-lookup"><span data-stu-id="d7b80-889">When a POCO entity does not have a change tracking proxy, changes are found by comparing the contents of your entities against a copy of a previous saved state.</span></span> <span data-ttu-id="d7b80-890">Essa comparação profunda se tornará um processo demorado quando você tem muitas entidades em seu contexto, ou quando suas entidades têm uma quantidade muito grande de propriedades, mesmo que nenhuma delas alterado desde a última comparação ocorreu.</span><span class="sxs-lookup"><span data-stu-id="d7b80-890">This deep comparison will become a lengthy process when you have many entities in your context, or when your entities have a very large amount of properties, even if none of them changed since the last comparison took place.</span></span>

<span data-ttu-id="d7b80-891">Em Resumo: você pagará um impacto ao criar o proxy de controle de alterações no desempenho, mas o controle de alterações o ajudará a acelerar o processo de detecção de alteração quando as entidades têm muitas propriedades ou quando você tem muitas entidades em seu modelo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-891">In summary: you’ll pay a performance hit when creating the change tracking proxy, but change tracking will help you speed up the change detection process when your entities have many properties or when you have many entities in your model.</span></span> <span data-ttu-id="d7b80-892">Para entidades com um pequeno número de propriedades em que a quantidade de entidades não aumentar muito, ter proxies de controle de alteração não pode não ser muito benéfico.</span><span class="sxs-lookup"><span data-stu-id="d7b80-892">For entities with a small number of properties where the amount of entities doesn’t grow too much, having change tracking proxies may not be of much benefit.</span></span>

## <a name="8-loading-related-entities"></a><span data-ttu-id="d7b80-893">Entidades relacionadas ao carregamento de 8</span><span class="sxs-lookup"><span data-stu-id="d7b80-893">8 Loading Related Entities</span></span>

### <a name="81-lazy-loading-vs-eager-loading"></a><span data-ttu-id="d7b80-894">8.1 vs de carregamento lentas. Carregamento adiantado</span><span class="sxs-lookup"><span data-stu-id="d7b80-894">8.1 Lazy Loading vs. Eager Loading</span></span>

<span data-ttu-id="d7b80-895">Entity Framework oferece várias maneiras diferentes para carregar as entidades relacionadas à sua entidade de destino.</span><span class="sxs-lookup"><span data-stu-id="d7b80-895">Entity Framework offers several different ways to load the entities that are related to your target entity.</span></span> <span data-ttu-id="d7b80-896">Por exemplo, quando você consulta para os produtos, há diferentes maneiras que os pedidos relacionados serão carregados no Gerenciador de estado do objeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-896">For example, when you query for Products, there are different ways that the related Orders will be loaded into the Object State Manager.</span></span> <span data-ttu-id="d7b80-897">Do ponto de vista do desempenho, a pergunta maiores serem consideradas ao carregar entidades relacionadas será se deve usar o carregamento lento ou o carregamento adiantado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-897">From a performance standpoint, the biggest question to consider when loading related entities will be whether to use Lazy Loading or Eager Loading.</span></span>

<span data-ttu-id="d7b80-898">Ao usar o carregamento adiantado, as entidades relacionadas são carregadas, juntamente com seu conjunto de entidades de destino.</span><span class="sxs-lookup"><span data-stu-id="d7b80-898">When using Eager Loading, the related entities are loaded along with your target entity set.</span></span> <span data-ttu-id="d7b80-899">Você pode usar uma instrução Include em sua consulta para indicar quais entidades que você deseja colocar relacionadas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-899">You use an Include statement in your query to indicate which related entities you want to bring in.</span></span>

<span data-ttu-id="d7b80-900">Ao usar o carregamento lento, sua consulta inicial traz apenas o conjunto de entidades de destino.</span><span class="sxs-lookup"><span data-stu-id="d7b80-900">When using Lazy Loading, your initial query only brings in the target entity set.</span></span> <span data-ttu-id="d7b80-901">Mas sempre que você acessar uma propriedade de navegação, outra consulta é emitida para o armazenamento para carregar a entidade relacionada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-901">But whenever you access a navigation property, another query is issued against the store to load the related entity.</span></span>

<span data-ttu-id="d7b80-902">Depois que uma entidade tiver sido carregada, quaisquer consultas adicionais para a entidade carregará diretamente do Gerenciador de estado de objeto, se você estiver usando o carregamento lento ou o carregamento adiantado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-902">Once an entity has been loaded, any further queries for the entity will load it directly from the Object State Manager, whether you are using lazy loading or eager loading.</span></span>

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a><span data-ttu-id="d7b80-903">8.2 como escolher entre o carregamento lento e o carregamento adiantado</span><span class="sxs-lookup"><span data-stu-id="d7b80-903">8.2 How to choose between Lazy Loading and Eager Loading</span></span>

<span data-ttu-id="d7b80-904">O importante é que você compreendeu a diferença entre o carregamento lento e o carregamento adiantado para que você possa fazer a escolha correta para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-904">The important thing is that you understand the difference between Lazy Loading and Eager Loading so that you can make the correct choice for your application.</span></span> <span data-ttu-id="d7b80-905">Isso ajudará você a avaliar a compensação entre várias solicitações no banco de dados em comparação com uma única solicitação que pode conter uma extensa carga útil.</span><span class="sxs-lookup"><span data-stu-id="d7b80-905">This will help you evaluate the tradeoff between multiple requests against the database versus a single request that may contain a large payload.</span></span> <span data-ttu-id="d7b80-906">Ele pode ser apropriado usar o carregamento adiantado em algumas partes do seu aplicativo e o carregamento lento em outras partes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-906">It may be appropriate to use eager loading in some parts of your application and lazy loading in other parts.</span></span>

<span data-ttu-id="d7b80-907">Um exemplo do que está acontecendo nos bastidores, suponha que você deseja consultar os clientes que moram no Reino Unido e sua contagem de ordem.</span><span class="sxs-lookup"><span data-stu-id="d7b80-907">As an example of what's happening under the hood, suppose you want to query for the customers who live in the UK and their order count.</span></span>

<span data-ttu-id="d7b80-908">**Usando o carregamento adiantado**</span><span class="sxs-lookup"><span data-stu-id="d7b80-908">**Using Eager Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="d7b80-909">**Usar o carregamento lento**</span><span class="sxs-lookup"><span data-stu-id="d7b80-909">**Using Lazy Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="d7b80-910">Ao usar o carregamento adiantado, você vai emitir uma única consulta que retorna todos os clientes e todos os pedidos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-910">When using eager loading, you'll issue a single query that returns all customers and all orders.</span></span> <span data-ttu-id="d7b80-911">O comando de armazenamento se parece com:</span><span class="sxs-lookup"><span data-stu-id="d7b80-911">The store command looks like:</span></span>

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

<span data-ttu-id="d7b80-912">Ao usar o carregamento lento, você vai emitir a consulta a seguir inicialmente:</span><span class="sxs-lookup"><span data-stu-id="d7b80-912">When using lazy loading, you'll issue the following query initially:</span></span>

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

<span data-ttu-id="d7b80-913">E cada vez que você acessa a propriedade de navegação de pedidos de um cliente outra consulta semelhante à seguinte é emitida para o repositório:</span><span class="sxs-lookup"><span data-stu-id="d7b80-913">And each time you access the Orders navigation property of a customer another query like the following is issued against the store:</span></span>

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

<span data-ttu-id="d7b80-914">Para obter mais informações, consulte o [Carregando objetos relacionados](https://msdn.microsoft.com/library/bb896272.aspx).</span><span class="sxs-lookup"><span data-stu-id="d7b80-914">For more information, see the [Loading Related Objects](https://msdn.microsoft.com/library/bb896272.aspx).</span></span>

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a><span data-ttu-id="d7b80-915">8.2.1 carregamento lento em comparação com o carregamento adiantado de folha de consulta</span><span class="sxs-lookup"><span data-stu-id="d7b80-915">8.2.1 Lazy Loading versus Eager Loading cheat sheet</span></span>

<span data-ttu-id="d7b80-916">Não há nenhum algo como uma única para escolher o carregamento adiantado em comparação com o carregamento lento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-916">There’s no such thing as a one-size-fits-all to choosing eager loading versus lazy loading.</span></span> <span data-ttu-id="d7b80-917">Tente primeiro entender as diferenças entre as duas estratégias para que você possa fazer uma decisão bem informada; Além disso, considere se seu código se ajusta a qualquer um dos seguintes cenários:</span><span class="sxs-lookup"><span data-stu-id="d7b80-917">Try first to understand the differences between both strategies so you can do a well informed decision; also, consider if your code fits to any of the following scenarios:</span></span>

| <span data-ttu-id="d7b80-918">Cenário</span><span class="sxs-lookup"><span data-stu-id="d7b80-918">Scenario</span></span>                                                                    | <span data-ttu-id="d7b80-919">Nosso sugestão</span><span class="sxs-lookup"><span data-stu-id="d7b80-919">Our Suggestion</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="d7b80-920">Você precisa acessar muitas propriedades de navegação de entidades buscadas?</span><span class="sxs-lookup"><span data-stu-id="d7b80-920">Do you need to access many navigation properties from the fetched entities?</span></span> | <span data-ttu-id="d7b80-921">**Não** -provavelmente fará as duas opções.</span><span class="sxs-lookup"><span data-stu-id="d7b80-921">**No** - Both options will probably do.</span></span> <span data-ttu-id="d7b80-922">No entanto, se a carga que está trazendo a sua consulta não é muito grande, que você pode enfrentar os benefícios de desempenho usando o carregamento adiantado, como ele vai exigir menos rede idas e vindas para materializar seus objetos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-922">However, if the payload your query is bringing is not too big, you may experience performance benefits by using Eager loading as it’ll require less network round trips to materialize your objects.</span></span> <br/> <br/> <span data-ttu-id="d7b80-923">**Sim** -se você precisar acessar muitas propriedades de navegação de entidades, você faria se por meio de várias incluem instruções em sua consulta com o carregamento adiantado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-923">**Yes** -  If you need to access many navigation properties from the entities, you’d do that by using multiple include statements in your query with Eager loading.</span></span> <span data-ttu-id="d7b80-924">As entidades mais incluir, maior será a carga de sua consulta retornará.</span><span class="sxs-lookup"><span data-stu-id="d7b80-924">The more entities you include, the bigger the payload your query will return.</span></span> <span data-ttu-id="d7b80-925">Depois que você inclui três ou mais entidades em sua consulta, considere alternar para lento ao carregar.</span><span class="sxs-lookup"><span data-stu-id="d7b80-925">Once you include three or more entities into your query, consider switching to Lazy loading.</span></span> |
| <span data-ttu-id="d7b80-926">Você sabe exatamente quais dados serão necessários no tempo de execução?</span><span class="sxs-lookup"><span data-stu-id="d7b80-926">Do you know exactly what data will be needed at run time?</span></span>                   | <span data-ttu-id="d7b80-927">**Não** -carregamento lento será melhor para você.</span><span class="sxs-lookup"><span data-stu-id="d7b80-927">**No** - Lazy loading will be better for you.</span></span> <span data-ttu-id="d7b80-928">Caso contrário, você pode acabar consultando dados que não será necessário.</span><span class="sxs-lookup"><span data-stu-id="d7b80-928">Otherwise, you may end up querying for data that you will not need.</span></span> <br/> <br/> <span data-ttu-id="d7b80-929">**Sim** - adiantado carregamento provavelmente é sua melhor aposta; ele o ajudará a carregar conjuntos de inteiros com mais rapidez.</span><span class="sxs-lookup"><span data-stu-id="d7b80-929">**Yes** - Eager loading is probably your best bet; it will help loading entire sets faster.</span></span> <span data-ttu-id="d7b80-930">Se sua consulta requer a buscar uma grande quantidade de dados, e isso se torna muito lento, em seguida, tente Lazy carregando em vez disso.</span><span class="sxs-lookup"><span data-stu-id="d7b80-930">If your query requires fetching a very large amount of data, and this becomes too slow, then try Lazy loading instead.</span></span>                                                                                                                                                                                                                                                       |
| <span data-ttu-id="d7b80-931">O código em execução longe de seu banco de dados?</span><span class="sxs-lookup"><span data-stu-id="d7b80-931">Is your code executing far from your database?</span></span> <span data-ttu-id="d7b80-932">(maior latência na rede)</span><span class="sxs-lookup"><span data-stu-id="d7b80-932">(increased network latency)</span></span>  | <span data-ttu-id="d7b80-933">**Não** – quando a latência de rede não é um problema, usar o carregamento lento pode simplificar o seu código.</span><span class="sxs-lookup"><span data-stu-id="d7b80-933">**No** - When the network latency is not an issue, using Lazy loading may simplify your code.</span></span> <span data-ttu-id="d7b80-934">Lembre-se de que a topologia do seu aplicativo pode mudar, tome a proximidade de banco de dados para concedidas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-934">Remember that the topology of your application may change, so don’t take database proximity for granted.</span></span> <br/> <br/> <span data-ttu-id="d7b80-935">**Sim** – quando a rede é um problema, somente você pode decidir o que melhor se adapta para seu cenário.</span><span class="sxs-lookup"><span data-stu-id="d7b80-935">**Yes** - When the network is a problem, only you can decide what fits better for your scenario.</span></span> <span data-ttu-id="d7b80-936">Normalmente o carregamento adiantado será melhor porque exige menos viagens de ida e volta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-936">Typically Eager loading will be better because it requires fewer round trips.</span></span>                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a><span data-ttu-id="d7b80-937">8.2.2 as preocupações de desempenho de with inclui vários</span><span class="sxs-lookup"><span data-stu-id="d7b80-937">8.2.2       Performance concerns with multiple Includes</span></span>

<span data-ttu-id="d7b80-938">Quando ouvimos questões de desempenho que envolvem problemas de tempo de resposta do servidor, a origem do problema é com frequência consultas com várias instruções Include.</span><span class="sxs-lookup"><span data-stu-id="d7b80-938">When we hear performance questions that involve server response time problems, the source of the issue is frequently queries with multiple Include statements.</span></span> <span data-ttu-id="d7b80-939">Enquanto incluindo entidades relacionadas em uma consulta seja eficiente, é importante entender o que está acontecendo nos bastidores.</span><span class="sxs-lookup"><span data-stu-id="d7b80-939">While including related entities in a query is powerful, it's important to understand what's happening under the covers.</span></span>

<span data-ttu-id="d7b80-940">Demora um tempo relativamente longo para uma consulta com várias instruções Include nele passar pelo compilador nosso plano interno para produzir o comando de armazenamento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-940">It takes a relatively long time for a query with multiple Include statements in it to go through our internal plan compiler to produce the store command.</span></span> <span data-ttu-id="d7b80-941">A maior parte desse tempo é gasto tentando otimizar a consulta resultante.</span><span class="sxs-lookup"><span data-stu-id="d7b80-941">The majority of this time is spent trying to optimize the resulting query.</span></span> <span data-ttu-id="d7b80-942">O comando de armazenamento gerado conterá um Outer Join ou Union para cada inclusão, dependendo do seu mapeamento.</span><span class="sxs-lookup"><span data-stu-id="d7b80-942">The generated store command will contain an Outer Join or Union for each Include, depending on your mapping.</span></span> <span data-ttu-id="d7b80-943">Consultas como este trará grandes gráficos conectados do banco de dados em uma única carga, que será acerbate quaisquer problemas de largura de banda, especialmente quando há muita de redundância na carga (por exemplo, quando vários níveis de inclusão são usados para percorrer associações a direção de um-para-muitos).</span><span class="sxs-lookup"><span data-stu-id="d7b80-943">Queries like this will bring in large connected graphs from your database in a single payload, which will acerbate any bandwidth issues, especially when there is a lot of redundancy in the payload (for example, when multiple levels of Include are used to traverse associations in the one-to-many direction).</span></span>

<span data-ttu-id="d7b80-944">Você pode verificar para casos em que suas consultas estão retornando excessivamente grandes cargas, acessando o TSQL subjacente para a consulta usando o ToTraceString e executando o comando de armazenamento no SQL Server Management Studio para ver o tamanho da carga.</span><span class="sxs-lookup"><span data-stu-id="d7b80-944">You can check for cases where your queries are returning excessively large payloads by accessing the underlying TSQL for the query by using ToTraceString and executing the store command in SQL Server Management Studio to see the payload size.</span></span> <span data-ttu-id="d7b80-945">Nesses casos, que você pode tentar reduzir o número de instruções Include na consulta para trazer os dados que necessários.</span><span class="sxs-lookup"><span data-stu-id="d7b80-945">In such cases you can try to reduce the number of Include statements in your query to just bring in the data you need.</span></span> <span data-ttu-id="d7b80-946">Ou, você poderá dividir a consulta em uma sequência menor de subconsultas, por exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-946">Or you may be able to break your query into a smaller sequence of subqueries, for example:</span></span>

<span data-ttu-id="d7b80-947">**Antes de interromper a consulta:**</span><span class="sxs-lookup"><span data-stu-id="d7b80-947">**Before breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="d7b80-948">**Depois de interromper a consulta:**</span><span class="sxs-lookup"><span data-stu-id="d7b80-948">**After breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="d7b80-949">Isso funcionará apenas em consultas rastreadas, como estamos fazendo uso da capacidade de contexto deve executar a correção de associação e a resolução de identidade automaticamente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-949">This will work only on tracked queries, as we are making use of the ability the context has to perform identity resolution and association fixup automatically.</span></span>

<span data-ttu-id="d7b80-950">Assim como acontece com carregamento lento, a desvantagem será mais consultas para cargas menores.</span><span class="sxs-lookup"><span data-stu-id="d7b80-950">As with lazy loading, the tradeoff will be more queries for smaller payloads.</span></span> <span data-ttu-id="d7b80-951">Você também pode usar projeções de propriedades individuais explicitamente selecionar apenas os dados que você precisa de cada entidade, mas você será não ser Carregando entidades nesse caso, e atualizações não terão suporte.</span><span class="sxs-lookup"><span data-stu-id="d7b80-951">You can also use projections of individual properties to explicitly select only the data you need from each entity, but you will not be loading entities in this case, and updates will not be supported.</span></span>

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a><span data-ttu-id="d7b80-952">8.2.3 solução alternativa de para que o carregamento lento de propriedades</span><span class="sxs-lookup"><span data-stu-id="d7b80-952">8.2.3 Workaround to get lazy loading of properties</span></span>

<span data-ttu-id="d7b80-953">Entity Framework atualmente não dá suporte a carregamento lento de propriedades escalares ou complexos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-953">Entity Framework currently doesn’t support lazy loading of scalar or complex properties.</span></span> <span data-ttu-id="d7b80-954">No entanto, em casos em que você tem uma tabela que inclui um objeto grande, como um BLOB, você pode usar a divisão de tabela para separar as propriedades grandes em uma entidade separada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-954">However, in cases where you have a table that includes a large object such as a BLOB, you can use table splitting to separate the large properties into a separate entity.</span></span> <span data-ttu-id="d7b80-955">Por exemplo, suponha que você tenha uma tabela Product que inclui uma coluna de foto varbinary.</span><span class="sxs-lookup"><span data-stu-id="d7b80-955">For example, suppose you have a Product table that includes a varbinary photo column.</span></span> <span data-ttu-id="d7b80-956">Se você não precisar com frequência acessar essa propriedade em suas consultas, você pode usar a divisão para trazer apenas as partes da entidade que você normalmente precisa de tabela.</span><span class="sxs-lookup"><span data-stu-id="d7b80-956">If you don't frequently need to access this property in your queries, you can use table splitting to bring in only the parts of the entity that you normally need.</span></span> <span data-ttu-id="d7b80-957">A entidade que representa a foto do produto será carregada apenas quando explicitamente necessário.</span><span class="sxs-lookup"><span data-stu-id="d7b80-957">The entity representing the product photo will only be loaded when you explicitly need it.</span></span>

<span data-ttu-id="d7b80-958">Um bom recurso que mostra como habilitar a divisão de tabela é a postagem no blog do Gil Fink "Tabela dividindo no Entity Framework": \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-958">A good resource that shows how to enable table splitting is Gil Fink's "Table Splitting in Entity Framework" blog post: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span></span>

## <a name="9-other-considerations"></a><span data-ttu-id="d7b80-959">9 outras considerações</span><span class="sxs-lookup"><span data-stu-id="d7b80-959">9 Other considerations</span></span>

### <a name="91-server-garbage-collection"></a><span data-ttu-id="d7b80-960">9.1 coleta de lixo de servidor</span><span class="sxs-lookup"><span data-stu-id="d7b80-960">9.1      Server Garbage Collection</span></span>

<span data-ttu-id="d7b80-961">Alguns usuários podem enfrentar a contenção de recursos que limita o paralelismo esperado quando o coletor de lixo não está configurado corretamente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-961">Some users might experience resource contention that limits the parallelism they are expecting when the Garbage Collector is not properly configured.</span></span> <span data-ttu-id="d7b80-962">Sempre que o EF é usado em um cenário multithreaded, ou em qualquer aplicativo que se parece com um sistema de servidor, certifique-se de habilitar a coleta de lixo do servidor.</span><span class="sxs-lookup"><span data-stu-id="d7b80-962">Whenever EF is used in a multithreaded scenario, or in any application that resembles a server-side system, make sure to enable Server Garbage Collection.</span></span> <span data-ttu-id="d7b80-963">Isso é feito através de uma configuração simple no arquivo de configuração de aplicativo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-963">This is done via a simple setting in your application config file:</span></span>

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

<span data-ttu-id="d7b80-964">Isso deve reduzir a contenção de thread e aumentar a taxa de transferência por até 30% em cenários de CPU saturado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-964">This should decrease your thread contention and increase your throughput by up to 30% in CPU saturated scenarios.</span></span> <span data-ttu-id="d7b80-965">Em termos gerais, você deve sempre testar como seu aplicativo se comporta usando a coleta de lixo clássico (que é melhor ajustados para cenários de lado do cliente e da interface do usuário), bem como a coleta de lixo do servidor.</span><span class="sxs-lookup"><span data-stu-id="d7b80-965">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span></span>

### <a name="92-autodetectchanges"></a><span data-ttu-id="d7b80-966">9.2 AutoDetectChanges</span><span class="sxs-lookup"><span data-stu-id="d7b80-966">9.2      AutoDetectChanges</span></span>

<span data-ttu-id="d7b80-967">Como mencionado anteriormente, o Entity Framework pode mostrar a problemas de desempenho quando o cache de objetos tem muitas entidades.</span><span class="sxs-lookup"><span data-stu-id="d7b80-967">As mentioned earlier, Entity Framework might show performance issues when the object cache has many entities.</span></span> <span data-ttu-id="d7b80-968">Determinadas operações, como adicionar, remover, localizar, entrada e SaveChanges, disparam chamadas a DetectChanges que podem consumir uma grande quantidade de CPU com base em quão grande tornou o cache de objetos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-968">Certain operations, such as Add, Remove, Find, Entry and SaveChanges, trigger calls to DetectChanges which might consume a large amount of CPU based on how large the object cache has become.</span></span> <span data-ttu-id="d7b80-969">A razão para isso é que o cache de objetos e a tentativa de Gerenciador de estado do objeto permanecer como sincronizados o máximo possível em cada operação executada em um contexto para que os dados produzidos é obrigatoriamente correto em uma ampla gama de cenários.</span><span class="sxs-lookup"><span data-stu-id="d7b80-969">The reason for this is that the object cache and the object state manager try to stay as synchronized as possible on each operation performed to a context so that the produced data is guaranteed to be correct under a wide array of scenarios.</span></span>

<span data-ttu-id="d7b80-970">Ele geralmente é uma boa prática para deixar a detecção de alterações automático do Entity Framework habilitada para toda a vida do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-970">It is generally a good practice to leave Entity Framework’s automatic change detection enabled for the entire life of your application.</span></span> <span data-ttu-id="d7b80-971">Se seu cenário está sendo afetado negativamente pelo alto uso da CPU e os perfis de indicam que o culpado é a chamada para DetectChanges, considere desativar temporariamente AutoDetectChanges na parte confidencial do seu código:</span><span class="sxs-lookup"><span data-stu-id="d7b80-971">If your scenario is being negatively affected by high CPU usage and your profiles indicate that the culprit is the call to DetectChanges, consider temporarily turning off AutoDetectChanges in the sensitive portion of your code:</span></span>

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

<span data-ttu-id="d7b80-972">Antes de desligar AutoDetectChanges, é bom entender o que isso pode causar o Entity Framework para perder a capacidade de rastrear certas informações sobre as alterações que estão ocorrendo nas entidades.</span><span class="sxs-lookup"><span data-stu-id="d7b80-972">Before turning off AutoDetectChanges, it’s good to understand that this might cause Entity Framework to lose its ability to track certain information about the changes that are taking place on the entities.</span></span> <span data-ttu-id="d7b80-973">Se tratadas de forma incorreta, isso pode causar inconsistência de dados em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-973">If handled incorrectly, this might cause data inconsistency on your application.</span></span> <span data-ttu-id="d7b80-974">Para obter mais informações sobre como desativar AutoDetectChanges, leia \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-974">For more information on turning off AutoDetectChanges, read \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span></span>

### <a name="93-context-per-request"></a><span data-ttu-id="d7b80-975">9.3 contexto por solicitação</span><span class="sxs-lookup"><span data-stu-id="d7b80-975">9.3      Context per request</span></span>

<span data-ttu-id="d7b80-976">Contextos do Entity Framework destinam-se a ser usado como a experiência de instâncias de curta duração para fornecer o desempenho ideal.</span><span class="sxs-lookup"><span data-stu-id="d7b80-976">Entity Framework’s contexts are meant to be used as short-lived instances in order to provide the most optimal performance experience.</span></span> <span data-ttu-id="d7b80-977">Contextos devem ser curtos vivia e descartadas e como tal, foram implementadas para ser muito leve e reutilize metadados sempre que possível.</span><span class="sxs-lookup"><span data-stu-id="d7b80-977">Contexts are expected to be short lived and discarded, and as such have been implemented to be very lightweight and reutilize metadata whenever possible.</span></span> <span data-ttu-id="d7b80-978">Em cenários de web, é importante ter isso em mente e não tem um contexto para obter mais informações que a duração de uma única solicitação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-978">In web scenarios it’s important to keep this in mind and not have a context for more than the duration of a single request.</span></span> <span data-ttu-id="d7b80-979">Da mesma forma, em cenários de não web contexto deve ser descartado com base na sua compreensão dos diferentes níveis de armazenamento em cache no Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="d7b80-979">Similarly, in non-web scenarios, context should be discarded based on your understanding of the different levels of caching in the Entity Framework.</span></span> <span data-ttu-id="d7b80-980">Em termos gerais, um Evite ter uma instância de contexto durante a vida útil do aplicativo, bem como contextos por thread e contextos estáticos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-980">Generally speaking, one should avoid having a context instance throughout the life of the application, as well as contexts per thread and static contexts.</span></span>

### <a name="94-database-null-semantics"></a><span data-ttu-id="d7b80-981">9.4 a semântica nula do banco de dados</span><span class="sxs-lookup"><span data-stu-id="d7b80-981">9.4      Database null semantics</span></span>

<span data-ttu-id="d7b80-982">Entity Framework por padrão irá gerar o código SQL que tem C\# semântica de comparação de null.</span><span class="sxs-lookup"><span data-stu-id="d7b80-982">Entity Framework by default will generate SQL code that has C\# null comparison semantics.</span></span> <span data-ttu-id="d7b80-983">Considere a seguinte consulta de exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-983">Consider the following example query:</span></span>

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

<span data-ttu-id="d7b80-984">Neste exemplo, estamos comparando um número de variáveis que permitem valor nulos em relação a propriedades que permitem valor nulas na entidade, como SupplierID e UnitPrice.</span><span class="sxs-lookup"><span data-stu-id="d7b80-984">In this example, we’re comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span></span> <span data-ttu-id="d7b80-985">O SQL gerado para esta consulta perguntará se o valor do parâmetro é o mesmo que o valor da coluna, ou se o parâmetro e os valores de coluna forem nulos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-985">The generated SQL for this query will ask if the parameter value is the same as the column value, or if both the parameter and the column values are null.</span></span> <span data-ttu-id="d7b80-986">Isso ocultará a forma como o servidor de banco de dados trata valores nulos e fornecerá um C consistente\# null experiência entre os fornecedores de banco de dados diferente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-986">This will hide the way the database server handles nulls and will provide a consistent C\# null experience across different database vendors.</span></span> <span data-ttu-id="d7b80-987">Por outro lado, o código gerado é um pouco intrincado e talvez não sejam executados bem quando a quantidade de comparações em where cresce na instrução da consulta para um grande número.</span><span class="sxs-lookup"><span data-stu-id="d7b80-987">On the other hand, the generated code is a bit convoluted and may not perform well when the amount of comparisons in the where statement of the query grows to a large number.</span></span>

<span data-ttu-id="d7b80-988">Uma maneira de lidar com essa situação é usando a semântica nula do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-988">One way to deal with this situation is by using database null semantics.</span></span> <span data-ttu-id="d7b80-989">Observe que isso pode se comportar de maneira diferente para o C\# null semântica desde agora o Entity Framework irá gerar SQL mais simples que expõe a forma como o mecanismo de banco de dados trata valores nulos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-989">Note that this might potentially behave differently to the C\# null semantics since now Entity Framework will generate simpler SQL that exposes the way the database engine handles null values.</span></span> <span data-ttu-id="d7b80-990">A semântica nula do banco de dados pode ser ativado por contexto com uma linha única de configuração com a configuração de contexto:</span><span class="sxs-lookup"><span data-stu-id="d7b80-990">Database null semantics can be activated per-context with one single configuration line against the context configuration:</span></span>

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

<span data-ttu-id="d7b80-991">Pequeno a médio porte consultas não exibirá uma melhoria de desempenho perceptível ao usar semântica nula do banco de dados, mas a diferença se tornará mais perceptível em consultas com um grande número de possíveis comparações nulas.</span><span class="sxs-lookup"><span data-stu-id="d7b80-991">Small to medium sized queries will not display a perceptible performance improvement when using database null semantics, but the difference will become more noticeable on queries with a large number of potential null comparisons.</span></span>

<span data-ttu-id="d7b80-992">Na consulta de exemplo acima, a diferença de desempenho era inferior a % 2 em um microbenchmark em execução em um ambiente controlado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-992">In the example query above, the performance difference was less than 2% in a microbenchmark running in a controlled environment.</span></span>

### <a name="95-async"></a><span data-ttu-id="d7b80-993">9.5 Async</span><span class="sxs-lookup"><span data-stu-id="d7b80-993">9.5      Async</span></span>

<span data-ttu-id="d7b80-994">Entity Framework 6 introduziu suporte das operações assíncronas quando executado no .NET 4.5 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="d7b80-994">Entity Framework 6 introduced support of async operations when running on .NET 4.5 or later.</span></span> <span data-ttu-id="d7b80-995">Na maior parte, os aplicativos que têm e/s relacionadas contenção irá se beneficiar mais usando a consulta assíncrona e salvar operações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-995">For the most part, applications that have IO related contention will benefit the most from using asynchronous query and save operations.</span></span> <span data-ttu-id="d7b80-996">Se seu aplicativo não sofre de contenção de e/s, o uso de async irão, nos melhores casos, executado de forma síncrona e retornar o resultado na mesma quantidade de tempo como uma chamada síncrona ou no pior caso, simplesmente adiar a execução para uma tarefa assíncrona e adicione tim extra e para a conclusão do seu cenário.</span><span class="sxs-lookup"><span data-stu-id="d7b80-996">If your application does not suffer from IO contention, the use of async will, in the best cases, run synchronously and return the result in the same amount of time as a synchronous call, or in the worst case, simply defer execution to an asynchronous task and add extra time to the completion of your scenario.</span></span>

<span data-ttu-id="d7b80-997">Para obter informações sobre o trabalho como assíncrono de programação que ajudarão você a decidir se async melhorará o desempenho do seu aplicativo visite [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span><span class="sxs-lookup"><span data-stu-id="d7b80-997">For information on how asynchronous programming work that will help you deciding if async will improve the performance of your application visit [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span></span> <span data-ttu-id="d7b80-998">Para obter mais informações sobre o uso de operações assíncronas no Entity Framework, consulte [consulta assíncrona e salvar](~/ef6/fundamentals/async.md
).</span><span class="sxs-lookup"><span data-stu-id="d7b80-998">For more information on the use of async operations on Entity Framework, see [Async Query and Save](~/ef6/fundamentals/async.md
).</span></span>

### <a name="96-ngen"></a><span data-ttu-id="d7b80-999">9.6 NGEN</span><span class="sxs-lookup"><span data-stu-id="d7b80-999">9.6      NGEN</span></span>

<span data-ttu-id="d7b80-1000">Entity Framework 6 não vem na instalação padrão do .NET framework.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1000">Entity Framework 6 does not come in the default installation of .NET framework.</span></span> <span data-ttu-id="d7b80-1001">Dessa forma, os assemblies do Entity Framework não são que NGen seria por padrão, que significa que todo o código do Entity Framework está sujeito a custos JIT'ing mesmos como qualquer outro assembly MSIL.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1001">As such, the Entity Framework assemblies are not NGEN’d by default which means that all the Entity Framework code is subject to the same JIT’ing costs as any other MSIL assembly.</span></span> <span data-ttu-id="d7b80-1002">Isso pode prejudicar a experiência de F5 ao desenvolver e também a inicialização a frio do seu aplicativo em ambientes de produção.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1002">This might degrade the F5 experience while developing and also the cold startup of your application in the production environments.</span></span> <span data-ttu-id="d7b80-1003">Para reduzir os custos de CPU e memória de JIT'ing é aconselhável NGEN o Entity Framework imagens conforme apropriado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1003">In order to reduce the CPU and memory costs of JIT’ing it is advisable to NGEN the Entity Framework images as appropriate.</span></span> <span data-ttu-id="d7b80-1004">Para obter mais informações sobre como melhorar o desempenho de inicialização do Entity Framework 6 com o NGEN, consulte [melhorando o desempenho de inicialização com o NGen](~/ef6/fundamentals/performance/ngen.md).</span><span class="sxs-lookup"><span data-stu-id="d7b80-1004">For more information on how to improve the startup performance of Entity Framework 6 with NGEN, see [Improving Startup Performance with NGen](~/ef6/fundamentals/performance/ngen.md).</span></span>

### <a name="97-code-first-versus-edmx"></a><span data-ttu-id="d7b80-1005">9.7 code First versus EDMX</span><span class="sxs-lookup"><span data-stu-id="d7b80-1005">9.7      Code First versus EDMX</span></span>

<span data-ttu-id="d7b80-1006">Motivos do Entity Framework sobre o problema de incompatibilidade de impedância entre a programação orientada a objeto e bancos de dados relacionais, fazendo com que uma representação na memória de modelo conceitual (os objetos), o esquema de armazenamento (o banco de dados) e um mapeamento entre o dois.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1006">Entity Framework reasons about the impedance mismatch problem between object oriented programming and relational databases by having an in-memory representation of the conceptual model (the objects), the storage schema (the database) and a mapping between the two.</span></span> <span data-ttu-id="d7b80-1007">Esses metadados é chamado um modelo de dados de entidade, ou EDM, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1007">This metadata is called an Entity Data Model, or EDM for short.</span></span> <span data-ttu-id="d7b80-1008">Partir esse EDM, Entity Framework será derivar as exibições para dados de ida e volta de objetos na memória no banco de dados e de volta.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1008">From this EDM, Entity Framework will derive the views to roundtrip data from the objects in memory to the database and back.</span></span>

<span data-ttu-id="d7b80-1009">Quando Entity Framework é usado com um arquivo EDMX formalmente que especifica o modelo conceitual, o esquema de armazenamento e o mapeamento, em seguida, o estágio de carregamento de modelo tem apenas validar que o EDM está correto (por exemplo, verifique se que não há mapeamentos estão faltando), em seguida, gerar os modos de exibição, valide os modos de exibição e ter esses metadados prontos para uso.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1009">When Entity Framework is used with an EDMX file that formally specifies the conceptual model, the storage schema, and the mapping, then the model loading stage only has to validate that the EDM is correct (for example, make sure that no mappings are missing), then generate the views, then validate the views and have this metadata ready for use.</span></span> <span data-ttu-id="d7b80-1010">Só pode, em seguida, uma consulta ser executada ou novos dados a ser salvo para o armazenamento de dados.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1010">Only then can a query be executed or new data be saved to the data store.</span></span>

<span data-ttu-id="d7b80-1011">Em seu cerne, a abordagem de Code First é um gerador de modelo de dados de entidade sofisticado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1011">The Code First approach is, at its heart, a sophisticated Entity Data Model generator.</span></span> <span data-ttu-id="d7b80-1012">O Entity Framework tem que produzir um EDM a partir do código fornecido. Isso é feito analisando as classes envolvidas no modelo, aplicar as convenções e definir o modelo por meio da API Fluent.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1012">The Entity Framework has to produce an EDM from the provided code; it does so by analyzing the classes involved in the model, applying conventions and configuring the model via the Fluent API.</span></span> <span data-ttu-id="d7b80-1013">Depois que o EDM é compilado, o Entity Framework essencialmente se comporta da mesma maneira que faria tivesse um arquivo EDMX foi presente no projeto.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1013">After the EDM is built, the Entity Framework essentially behaves the same way as it would had an EDMX file been present in the project.</span></span> <span data-ttu-id="d7b80-1014">Portanto, a criação do modelo do Code First adiciona complexidade extra que se traduz em um tempo de inicialização mais lento para o Entity Framework em comparação com a necessidade de um EDMX.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1014">Thus, building the model from Code First adds extra complexity that translates into a slower startup time for the Entity Framework when compared to having an EDMX.</span></span> <span data-ttu-id="d7b80-1015">O custo depende completamente o tamanho e a complexidade do modelo que está sendo criado.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1015">The cost is completely dependent on the size and complexity of the model that’s being built.</span></span>

<span data-ttu-id="d7b80-1016">Ao escolher usar EDMX versus Code First, é importante saber que a flexibilidade introduzida pelo Code First aumenta o custo da criação do modelo pela primeira vez.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1016">When choosing to use EDMX versus Code First, it’s important to know that the flexibility introduced by Code First increases the cost of building the model for the first time.</span></span> <span data-ttu-id="d7b80-1017">Se seu aplicativo pode suportar o custo dessa carga pela primeira vez, em seguida, normalmente Code First será a maneira preferencial para ir.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1017">If your application can withstand the cost of this first-time load then typically Code First will be the preferred way to go.</span></span>

## <a name="10-investigating-performance"></a><span data-ttu-id="d7b80-1018">Desempenho de investigação de 10</span><span class="sxs-lookup"><span data-stu-id="d7b80-1018">10 Investigating Performance</span></span>

### <a name="101-using-the-visual-studio-profiler"></a><span data-ttu-id="d7b80-1019">10.1 usando o Visual Studio Profiler</span><span class="sxs-lookup"><span data-stu-id="d7b80-1019">10.1 Using the Visual Studio Profiler</span></span>

<span data-ttu-id="d7b80-1020">Se você estiver tendo problemas de desempenho com o Entity Framework, você pode usar um criador de perfil, como no Visual Studio para ver onde seu aplicativo está gastando tempo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1020">If you are having performance issues with the Entity Framework, you can use a profiler like the one built into Visual Studio to see where your application is spending its time.</span></span> <span data-ttu-id="d7b80-1021">Esta é a ferramenta são usadas para gerar os gráficos de pizza na postagem do blog "Explorando o desempenho do ADO.NET Entity Framework - parte 1" ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) que mostram onde o Entity Framework gasta seu tempo durante consultas frios e quentes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1021">This is the tool we used to generate the pie charts in the “Exploring the Performance of the ADO.NET Entity Framework - Part 1” blog post ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) that show where Entity Framework spends its time during cold and warm queries.</span></span>

<span data-ttu-id="d7b80-1022">A postagem do blog "Criação de perfil Entity Framework usando o Profiler de 2010 Visual Studio" gravada pelos dados e modelagem equipe consultiva para clientes mostra um exemplo do mundo real de como eles usaram o criador de perfil para investigar um problema de desempenho.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1022">The "Profiling Entity Framework using the Visual Studio 2010 Profiler" blog post written by the Data and Modeling Customer Advisory Team shows a real-world example of how they used the profiler to investigate a performance problem.</span></span><span data-ttu-id="d7b80-1023">  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1023">  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span></span> <span data-ttu-id="d7b80-1024">Esta postagem foi escrita para um aplicativo do windows.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1024">This post was written for a windows application.</span></span> <span data-ttu-id="d7b80-1025">Se você precisar criar o perfil de um aplicativo web do Windows Performance Recorder (WPR) e o analisador de desempenho do Windows (WPA) das ferramentas podem funcionar melhor do que o trabalho do Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1025">If you need to profile a web application the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA) tools may work better than working from Visual Studio.</span></span> <span data-ttu-id="d7b80-1026">WPR e WPA fazem parte do Toolkit de desempenho do Windows que é incluído com o Windows Assessment and Deployment Kit ( [ http://www.microsoft.com/download/details.aspx?id=39982 ](https://www.microsoft.com/download/details.aspx?id=39982)).</span><span class="sxs-lookup"><span data-stu-id="d7b80-1026">WPR and WPA are part of the Windows Performance Toolkit which is included with the Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).</span></span>

### <a name="102-applicationdatabase-profiling"></a><span data-ttu-id="d7b80-1027">10.2 aplicativo/banco de dados de criação de perfil</span><span class="sxs-lookup"><span data-stu-id="d7b80-1027">10.2 Application/Database profiling</span></span>

<span data-ttu-id="d7b80-1028">Ferramentas como o criador de perfil incorporado ao Visual Studio lhe dizer onde seu aplicativo está gastando tempo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1028">Tools like the profiler built into Visual Studio tell you where your application is spending time.</span></span><span data-ttu-id="d7b80-1029">  Outro tipo de criador de perfil está disponível que executa a análise dinâmica de seu aplicativo em execução, na produção ou pré-produção dependendo das necessidades e procura por antipadrões de acesso de banco de dados e armadilhas comuns.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1029">  Another type of profiler is available that performs dynamic analysis of your running application, either in production or pre-production depending on needs, and looks for common pitfalls and anti-patterns of database access.</span></span>

<span data-ttu-id="d7b80-1030">Dois criadores de perfil disponíveis no mercado são o Entity Framework Profiler ( \<http://efprof.com>) e ORMProfiler ( \<http://ormprofiler.com>).</span><span class="sxs-lookup"><span data-stu-id="d7b80-1030">Two commercially available profilers are the Entity Framework Profiler ( \<http://efprof.com>) and ORMProfiler ( \<http://ormprofiler.com>).</span></span>

<span data-ttu-id="d7b80-1031">Se seu aplicativo for um aplicativo MVC usando o Code First, você pode usar o MiniProfiler da StackExchange.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1031">If your application is an MVC application using Code First, you can use StackExchange's MiniProfiler.</span></span> <span data-ttu-id="d7b80-1032">Scott Hanselman descreve esta ferramenta em seu blog em: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1032">Scott Hanselman describes this tool in his blog at: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span></span>

<span data-ttu-id="d7b80-1033">Para obter mais informações sobre a criação de perfil de atividade de banco de dados do seu aplicativo, consulte artigo do MSDN Magazine de Julie [atividade de banco de dados de criação de perfil no Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span><span class="sxs-lookup"><span data-stu-id="d7b80-1033">For more information on profiling your application's database activity, see Julie Lerman's MSDN Magazine article titled [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span></span>

### <a name="103-database-logger"></a><span data-ttu-id="d7b80-1034">10.3 agente de log do banco de dados</span><span class="sxs-lookup"><span data-stu-id="d7b80-1034">10.3 Database logger</span></span>

<span data-ttu-id="d7b80-1035">Se você estiver usando o Entity Framework 6 também considere usar a funcionalidade de registro em log interno.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1035">If you are using Entity Framework 6 also consider using the built-in logging functionality.</span></span> <span data-ttu-id="d7b80-1036">A propriedade de banco de dados do contexto pode ser instruída a fazer sua atividade por meio de uma configuração de uma linha simples:</span><span class="sxs-lookup"><span data-stu-id="d7b80-1036">The Database property of the context can be instructed to log its activity via a simple one-line configuration:</span></span>

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

<span data-ttu-id="d7b80-1037">Neste exemplo, a atividade de banco de dados será registrada no console, mas a propriedade de Log pode ser configurada para chamar qualquer ação&lt;cadeia de caracteres&gt; delegar.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1037">In this example the database activity will be logged to the console, but the Log property can be configured to call any Action&lt;string&gt; delegate.</span></span>

<span data-ttu-id="d7b80-1038">Se você quiser habilitar o registro em log do banco de dados sem recompilar e você estiver usando o Entity Framework 6.1 ou posterior, você pode fazer isso adicionando um interceptor no arquivo Web. config ou App. config do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1038">If you want to enable database logging without recompiling, and you are using Entity Framework 6.1 or later, you can do so by adding an interceptor in the web.config or app.config file of your application.</span></span>

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

<span data-ttu-id="d7b80-1039">Para obter mais informações sobre como adicionar o registro em log sem recompilar acesse \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1039">For more information on how to add logging without recompiling go to \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span></span>

## <a name="11-appendix"></a><span data-ttu-id="d7b80-1040">Apêndice 11</span><span class="sxs-lookup"><span data-stu-id="d7b80-1040">11 Appendix</span></span>

### <a name="111-a-test-environment"></a><span data-ttu-id="d7b80-1041">11.1 ambiente de teste de r.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1041">11.1 A. Test Environment</span></span>

<span data-ttu-id="d7b80-1042">Esse ambiente usa uma configuração de computador 2 com o banco de dados em um computador separado do aplicativo cliente.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1042">This environment uses a 2-machine setup with the database on a separate machine from the client application.</span></span> <span data-ttu-id="d7b80-1043">Computadores estão no mesmo rack, para que a latência de rede é relativamente baixo, mas mais realista que o ambiente de um único computador.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1043">Machines are in the same rack, so network latency is relatively low, but more realistic than a single-machine environment.</span></span>

#### <a name="1111-app-server"></a><span data-ttu-id="d7b80-1044">11.1.1 servidor de aplicativo</span><span class="sxs-lookup"><span data-stu-id="d7b80-1044">11.1.1       App Server</span></span>

##### <a name="11111-software-environment"></a><span data-ttu-id="d7b80-1045">11.1.1.1 ambiente de software</span><span class="sxs-lookup"><span data-stu-id="d7b80-1045">11.1.1.1      Software Environment</span></span>

-   <span data-ttu-id="d7b80-1046">Ambiente de Software do Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="d7b80-1046">Entity Framework 4 Software Environment</span></span>
    -   <span data-ttu-id="d7b80-1047">Nome do sistema operacional: Windows Server 2008 R2 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1047">OS Name: Windows Server 2008 R2 Enterprise SP1.</span></span>
    -   <span data-ttu-id="d7b80-1048">Visual Studio 2010 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1048">Visual Studio 2010 – Ultimate.</span></span>
    -   <span data-ttu-id="d7b80-1049">Visual Studio 2010 SP1 (apenas para algumas comparações).</span><span class="sxs-lookup"><span data-stu-id="d7b80-1049">Visual Studio 2010 SP1 (only for some comparisons).</span></span>
-   <span data-ttu-id="d7b80-1050">Ambiente de Software do Entity Framework 5 e 6</span><span class="sxs-lookup"><span data-stu-id="d7b80-1050">Entity Framework 5 and 6 Software Environment</span></span>
    -   <span data-ttu-id="d7b80-1051">Nome do sistema operacional: Windows 8,1 Enterprise</span><span class="sxs-lookup"><span data-stu-id="d7b80-1051">OS Name: Windows 8.1 Enterprise</span></span>
    -   <span data-ttu-id="d7b80-1052">Visual Studio 2013 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1052">Visual Studio 2013 – Ultimate.</span></span>

##### <a name="11112-hardware-environment"></a><span data-ttu-id="d7b80-1053">11.1.1.2 ambiente de hardware</span><span class="sxs-lookup"><span data-stu-id="d7b80-1053">11.1.1.2      Hardware Environment</span></span>

-   <span data-ttu-id="d7b80-1054">Processador duplo:     Intel (r) Xeon (r) CPU L5520 W3530 2,27 GHz, 2261 Mhz8 GHz, 4 núcleos e processadores lógicos 84.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1054">Dual Processor:     Intel(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 Core(s), 84 Logical Processor(s).</span></span>
-   <span data-ttu-id="d7b80-1055">RamRAM 2412 GB.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1055">2412 GB RamRAM.</span></span>
-   <span data-ttu-id="d7b80-1056">136 GB SCSI250GB SATA 7200 rpm 3GB/s unidade dividido em partições de 4.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1056">136 GB SCSI250GB SATA 7200 rpm 3GB/s drive split into 4 partitions.</span></span>

#### <a name="1112-db-server"></a><span data-ttu-id="d7b80-1057">11.1.2 servidor de banco de dados</span><span class="sxs-lookup"><span data-stu-id="d7b80-1057">11.1.2       DB server</span></span>

##### <a name="11121-software-environment"></a><span data-ttu-id="d7b80-1058">11.1.2.1 ambiente de software</span><span class="sxs-lookup"><span data-stu-id="d7b80-1058">11.1.2.1      Software Environment</span></span>

-   <span data-ttu-id="d7b80-1059">Nome do sistema operacional: Windows Server 2008 R28.1 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1059">OS Name: Windows Server 2008 R28.1 Enterprise SP1.</span></span>
-   <span data-ttu-id="d7b80-1060">SQL Server 2008 R22012.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1060">SQL Server 2008 R22012.</span></span>

##### <a name="11122-hardware-environment"></a><span data-ttu-id="d7b80-1061">11.1.2.2 ambiente de hardware</span><span class="sxs-lookup"><span data-stu-id="d7b80-1061">11.1.2.2      Hardware Environment</span></span>

-   <span data-ttu-id="d7b80-1062">Processador único: Intel (r) Xeon (r) CPU L5520 2,27 GHz, 2261 MhzES-1620 0 @ 3,60 GHz, 4 núcleos, 8 processadores lógicos.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1062">Single Processor: Intel(R) Xeon(R) CPU L5520  @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 Core(s), 8 Logical Processor(s).</span></span>
-   <span data-ttu-id="d7b80-1063">RamRAM 824 GB.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1063">824 GB RamRAM.</span></span>
-   <span data-ttu-id="d7b80-1064">465 GB ATA500GB SATA 7200 rpm 6GB/s unidade dividido em partições de 4.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1064">465 GB ATA500GB SATA 7200 rpm 6GB/s drive split into 4 partitions.</span></span>

### <a name="112-b-query-performance-comparison-tests"></a><span data-ttu-id="d7b80-1065">11.2 testes de comparação de desempenho de consulta B.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1065">11.2      B. Query performance comparison tests</span></span>

<span data-ttu-id="d7b80-1066">O modelo do Northwind foi usado para executar esses testes.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1066">The Northwind model was used to execute these tests.</span></span> <span data-ttu-id="d7b80-1067">Ele foi gerado do banco de dados usando o Entity Framework designer.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1067">It was generated from the database using the Entity Framework designer.</span></span> <span data-ttu-id="d7b80-1068">Em seguida, o código a seguir foi usado para comparar o desempenho das opções de execução de consulta:</span><span class="sxs-lookup"><span data-stu-id="d7b80-1068">Then, the following code was used to compare the performance of the query execution options:</span></span>

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a><span data-ttu-id="d7b80-1069">C. 11.3 Navision modelo</span><span class="sxs-lookup"><span data-stu-id="d7b80-1069">11.3 C. Navision Model</span></span>

<span data-ttu-id="d7b80-1070">O banco de dados Navision é um grande banco de dados usado para a demonstração do Microsoft Dynamics – painel de navegação.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1070">The Navision database is a large database used to demo Microsoft Dynamics – NAV.</span></span> <span data-ttu-id="d7b80-1071">O modelo conceitual gerado contém conjuntos de entidade 1005 e 4227 associações.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1071">The generated conceptual model contains 1005 entity sets and 4227 association sets.</span></span> <span data-ttu-id="d7b80-1072">O modelo usado no teste é "simples" – nenhuma herança foi adicionada a ele.</span><span class="sxs-lookup"><span data-stu-id="d7b80-1072">The model used in the test is “flat” – no inheritance has been added to it.</span></span>

#### <a name="1131-queries-used-for-navision-tests"></a><span data-ttu-id="d7b80-1073">11.3.1 consultas de usadas para testes de Navision</span><span class="sxs-lookup"><span data-stu-id="d7b80-1073">11.3.1 Queries used for Navision tests</span></span>

<span data-ttu-id="d7b80-1074">Na lista de consultas usada com o modelo Navision contém 3 categorias de consultas do Entity SQL:</span><span class="sxs-lookup"><span data-stu-id="d7b80-1074">The queries list used with the Navision model contains 3 categories of Entity SQL queries:</span></span>

##### <a name="11311-lookup"></a><span data-ttu-id="d7b80-1075">11.3.1.1 pesquisa de</span><span class="sxs-lookup"><span data-stu-id="d7b80-1075">11.3.1.1 Lookup</span></span>

<span data-ttu-id="d7b80-1076">Uma consulta de pesquisa simples com nenhuma agregação</span><span class="sxs-lookup"><span data-stu-id="d7b80-1076">A simple lookup query with no aggregations</span></span>

-   <span data-ttu-id="d7b80-1077">Contagem: 16232</span><span class="sxs-lookup"><span data-stu-id="d7b80-1077">Count: 16232</span></span>
-   <span data-ttu-id="d7b80-1078">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-1078">Example:</span></span>

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a><span data-ttu-id="d7b80-1079">11.3.1.2 SingleAggregating</span><span class="sxs-lookup"><span data-stu-id="d7b80-1079">11.3.1.2 SingleAggregating</span></span>

<span data-ttu-id="d7b80-1080">Uma consulta normal de BI com várias agregações, mas nenhum subtotais (consulta única)</span><span class="sxs-lookup"><span data-stu-id="d7b80-1080">A normal BI query with multiple aggregations, but no subtotals (single query)</span></span>

-   <span data-ttu-id="d7b80-1081">Contagem: 2313</span><span class="sxs-lookup"><span data-stu-id="d7b80-1081">Count: 2313</span></span>
-   <span data-ttu-id="d7b80-1082">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-1082">Example:</span></span>

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

<span data-ttu-id="d7b80-1083">Onde MDF\_SessionLogin\_tempo\_Max () é definido no modelo como:</span><span class="sxs-lookup"><span data-stu-id="d7b80-1083">Where MDF\_SessionLogin\_Time\_Max() is defined in the model as:</span></span>

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a><span data-ttu-id="d7b80-1084">11.3.1.3 AggregatingSubtotals</span><span class="sxs-lookup"><span data-stu-id="d7b80-1084">11.3.1.3 AggregatingSubtotals</span></span>

<span data-ttu-id="d7b80-1085">Uma consulta de BI com agregações e subtotais (por meio de unir tudo)</span><span class="sxs-lookup"><span data-stu-id="d7b80-1085">A BI query with aggregations and subtotals (via union all)</span></span>

-   <span data-ttu-id="d7b80-1086">Contagem: 178</span><span class="sxs-lookup"><span data-stu-id="d7b80-1086">Count: 178</span></span>
-   <span data-ttu-id="d7b80-1087">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="d7b80-1087">Example:</span></span>

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
